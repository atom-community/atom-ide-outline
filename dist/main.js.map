{"version":3,"file":"main.js","sources":["../node_modules/atom-ide-base/src-commons-ui/scrollIntoView.ts","../node_modules/atom-ide-base/src-commons-ui/items.ts","../node_modules/fast-equals/src/utils.ts","../node_modules/fast-equals/src/comparator.ts","../node_modules/fast-equals/src/index.ts","../src/utils.ts","../src/outlineView.ts","../node_modules/atom-ide-base/src-commons-atom/ProviderRegistry.ts","../node_modules/atom-ide-base/src-commons-atom/getCwd.ts","../node_modules/atom-ide-base/src-commons-atom/range.ts","../node_modules/atom-ide-base/src-commons-atom/errors.ts","../node_modules/atom-ide-base/src-commons-atom/editor-largeness.ts","../node_modules/atom-ide-base/src-commons-atom/index.ts","../src/statuses.ts","../node_modules/lodash/isObject.js","../node_modules/lodash/_root.js","../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/now.js","../node_modules/lodash/_trimmedEndIndex.js","../node_modules/lodash/_baseTrim.js","../node_modules/lodash/_Symbol.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/isSymbol.js","../node_modules/lodash/isObjectLike.js","../node_modules/lodash/toNumber.js","../node_modules/lodash/debounce.js","../node_modules/tslib/tslib.es6.js","../src/call-hierarchy/call-hierarchy-view.ts","../src/call-hierarchy/tab-handler.ts","../src/call-hierarchy/main.ts","../src/main.ts"],"sourcesContent":["/* globals getComputedStyle */\n\n/**\n * Use these functions instead of `Element::scrollIntoView()` and `Element::scrollIntoViewIfNeeded()`!\n *\n * We've had a recurring issue in Nuclide (e.g. T20028138) where the UI would shift, leaving part of the workspace\n * element offscreen and a blank area in the window. This was caused by called to the native `scrollIntoView()` and\n * `scrollIntoViewIfNeeded()` which, according to the spec, has two potentially surprising behaviors:\n *\n * 1. It scrolls every scrollable ancestor (not just the closest), where\n * 2. \"scrollable\" is explicitly defined to include elements with `overflow: hidden`\n *\n * This is surprising because `overflow: hidden` is typically used to make elements *not scrollable*.\n *\n * Once the `overflow: hidden` element is scrolled, the user has no way to return it to its original position (as it has\n * no scrollbars).\n *\n * Note that this API doesn't support smooth scrolling. If that becomes necessary, we'll need to come up with a better fix.\n *\n * It's tempting to assume that using `scrollIntoViewIfNeeded()` would fix this issue, however, if the window is small\n * enough so that no amount of scrolling the desired scrollable element would ever reveal the element you're trying to,\n * the browser will keep scrolling ancestors.\n */\n\nexport function scrollIntoView(el: Element, alignToTop?: boolean): void {\n  const scrollTops = getScrollTops(el)\n  el.scrollIntoView(alignToTop)\n  restoreOverflowHiddenScrollTops(scrollTops)\n}\n\nexport type ElementExtended = Element & { scrollIntoViewIfNeeded?: (shouldCenter: boolean) => void }\n\nexport function scrollIntoViewIfNeeded(el: Element, center: boolean = true): void {\n  const scrollTops = getScrollTops(el)\n  // eslint-disable-next-line no-unused-expressions\n  ;(el as ElementExtended).scrollIntoViewIfNeeded?.(center) ?? el.scrollIntoView(center)\n  restoreOverflowHiddenScrollTops(scrollTops)\n}\n\nfunction getScrollTops(el_: Element): Map<Element, number> {\n  let el: Element | null = el_\n  const scrollTops = new Map<Element, number>()\n  while (el !== null) {\n    scrollTops.set(el, el.scrollTop)\n    el = el.parentElement\n  }\n  return scrollTops\n}\n\nfunction restoreOverflowHiddenScrollTops(scrollTops: Map<Element, number>): void {\n  scrollTops.forEach((scrollTop, el) => {\n    if (el.scrollTop !== scrollTop && isOverflowHidden(el)) {\n      el.scrollTop = scrollTop\n    }\n  })\n}\n\nexport function isOverflowHidden(el: HTMLElement | SVGElement | Element): boolean {\n  const overflowStyle = (el as HTMLElement)?.style.overflow\n  const overflow = overflowStyle ?? getComputedStyle(el).overflow\n  return overflow === \"hidden\"\n}\n","import type { Dock, ViewRegistry } from \"atom\"\n\n/**\n * A function to detect if an item (view) is visible in Atom. This is useful to skip code excecution or updating when\n * the item is not visible.\n *\n * @param item This is an item that is stored in {ViewRegistry}. It has the same type of the argument that you pass to\n *   `atom.view.getView(item)`.\n */\nexport function isItemVisible(item: Parameters<ViewRegistry[\"getView\"]>[0] | undefined | null) {\n  if (item === undefined || item === null) {\n    return false\n  }\n  // check the HTMLElement itself (important for when the dock/container is visible but the tab is not selected)\n  // try getting the element\n  const element = getItemElement(item)\n  if (element !== undefined && !isElementVisible(element)) {\n    return false\n    // if it we can't detect the invisiblity using HTML we need to consider Atom's context so we continue\n  }\n  // etch component\n  // if (item?.component?.visible === false) {\n  //   return false\n  // }\n  const paneContainer = atom.workspace.paneContainerForItem(item)\n  // if no container it is not visible\n  if (paneContainer === undefined) {\n    return false\n  } else if (typeof (paneContainer as any).isVisible === \"function\") {\n    // use Dock.isVisible()\n    return (paneContainer as Dock).isVisible()\n  } else {\n    // it is visible (when paneContainer is not a dock like TextEditor)\n    return true\n  }\n}\n\n/**\n * A function to detect if an HTMLElement is visible. It doesn't consider the Atom context. To detect if an item is\n * visible in Atom use {isItemVisible} instead This is useful to skip code excecution or updating when the element is\n * not visible.\n *\n * @param element\n */\nexport function isElementVisible(element: HTMLElement) {\n  if (\n    element instanceof HTMLElement &&\n    (element.style.display === \"none\" || element.hidden || element.offsetHeight === 0)\n  ) {\n    return false\n  }\n  return true\n}\n\n/** Get the HTMLElement of an item using `.getElement()` or `.element` */\nexport function getItemElement(item: object | undefined | null) {\n  if (item === undefined || item === null) {\n    return undefined\n  }\n  return typeof (item as any).getElement === \"function\"\n    ? (item as { getElement: () => HTMLElement }).getElement()\n    : (item as { element: HTMLElement | undefined }).element\n}\n","const HAS_WEAKSET_SUPPORT = typeof WeakSet === 'function';\n\nconst { keys } = Object;\n\ntype Cache = {\n  add: (value: any) => void;\n  has: (value: any) => boolean;\n};\n\nexport type EqualityComparator = (a: any, b: any, meta?: any) => boolean;\n\n/**\n * are the values passed strictly equal or both NaN\n *\n * @param a the value to compare against\n * @param b the value to test\n * @returns are the values equal by the SameValueZero principle\n */\nexport function sameValueZeroEqual(a: any, b: any) {\n  return a === b || (a !== a && b !== b);\n}\n\n/**\n * is the value a plain object\n *\n * @param value the value to test\n * @returns is the value a plain object\n */\nexport function isPlainObject(value: any) {\n  return value.constructor === Object || value.constructor == null;\n}\n\n/**\n * is the value promise-like (meaning it is thenable)\n *\n * @param value the value to test\n * @returns is the value promise-like\n */\nexport function isPromiseLike(value: any) {\n  return !!value && typeof value.then === 'function';\n}\n\n/**\n * is the value passed a react element\n *\n * @param value the value to test\n * @returns is the value a react element\n */\nexport function isReactElement(value: any) {\n  return !!(value && value.$$typeof);\n}\n\n/**\n * in cases where WeakSet is not supported, creates a new custom\n * object that mimics the necessary API aspects for cache purposes\n *\n * @returns the new cache object\n */\nexport function getNewCacheFallback(): Cache {\n  const values: any[] = [];\n\n  return {\n    add(value: any) {\n      values.push(value);\n    },\n\n    has(value: any) {\n      return values.indexOf(value) !== -1;\n    },\n  };\n}\n\n/**\n * get a new cache object to prevent circular references\n *\n * @returns the new cache object\n */\nexport const getNewCache = ((canUseWeakMap: boolean) => {\n  if (canUseWeakMap) {\n    return function _getNewCache(): Cache {\n      return new WeakSet();\n    };\n  }\n\n  return getNewCacheFallback;\n})(HAS_WEAKSET_SUPPORT);\n\n/**\n * create a custom isEqual handler specific to circular objects\n *\n * @param [isEqual] the isEqual comparator to use instead of isDeepEqual\n * @returns the method to create the `isEqual` function\n */\nexport function createCircularEqualCreator(isEqual?: EqualityComparator) {\n  return function createCircularEqual(comparator: EqualityComparator) {\n    const _comparator = isEqual || comparator;\n\n    return function circularEqual(\n      a: any,\n      b: any,\n      cache: Cache = getNewCache(),\n    ) {\n      const isCacheableA = !!a && typeof a === 'object';\n      const isCacheableB = !!b && typeof b === 'object';\n\n      if (isCacheableA || isCacheableB) {\n        const hasA = isCacheableA && cache.has(a);\n        const hasB = isCacheableB && cache.has(b);\n\n        if (hasA || hasB) {\n          return hasA && hasB;\n        }\n\n        if (isCacheableA) {\n          cache.add(a);\n        }\n\n        if (isCacheableB) {\n          cache.add(b);\n        }\n      }\n\n      return _comparator(a, b, cache);\n    };\n  };\n}\n\n/**\n * are the arrays equal in value\n *\n * @param a the array to test\n * @param b the array to test against\n * @param isEqual the comparator to determine equality\n * @param meta the meta object to pass through\n * @returns are the arrays equal\n */\nexport function areArraysEqual(\n  a: any[],\n  b: any[],\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  let index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (!isEqual(a[index], b[index], meta)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * are the maps equal in value\n *\n * @param a the map to test\n * @param b the map to test against\n * @param isEqual the comparator to determine equality\n * @param meta the meta map to pass through\n * @returns are the maps equal\n */\nexport function areMapsEqual(\n  a: Map<any, any>,\n  b: Map<any, any>,\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  let isValueEqual = a.size === b.size;\n\n  if (isValueEqual && a.size) {\n    a.forEach((aValue, aKey) => {\n      if (isValueEqual) {\n        isValueEqual = false;\n\n        b.forEach((bValue, bKey) => {\n          if (!isValueEqual && isEqual(aKey, bKey, meta)) {\n            isValueEqual = isEqual(aValue, bValue, meta);\n          }\n        });\n      }\n    });\n  }\n\n  return isValueEqual;\n}\n\ntype Dictionary<Type> = {\n  [key: string]: Type;\n  [index: number]: Type;\n};\n\nconst OWNER = '_owner';\n\nconst hasOwnProperty = Function.prototype.bind.call(\n  Function.prototype.call,\n  Object.prototype.hasOwnProperty,\n);\n\n/**\n * are the objects equal in value\n *\n * @param a the object to test\n * @param b the object to test against\n * @param isEqual the comparator to determine equality\n * @param meta the meta object to pass through\n * @returns are the objects equal\n */\nexport function areObjectsEqual(\n  a: Dictionary<any>,\n  b: Dictionary<any>,\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  const keysA = keys(a);\n\n  let index = keysA.length;\n\n  if (keys(b).length !== index) {\n    return false;\n  }\n\n  if (index) {\n    let key: string;\n\n    while (index-- > 0) {\n      key = keysA[index];\n\n      if (key === OWNER) {\n        const reactElementA = isReactElement(a);\n        const reactElementB = isReactElement(b);\n\n        if (\n          (reactElementA || reactElementB) &&\n          reactElementA !== reactElementB\n        ) {\n          return false;\n        }\n      }\n\n      if (!hasOwnProperty(b, key) || !isEqual(a[key], b[key], meta)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * are the regExps equal in value\n *\n * @param a the regExp to test\n * @param b the regExp to test agains\n * @returns are the regExps equal\n */\nexport function areRegExpsEqual(a: RegExp, b: RegExp) {\n  return (\n    a.source === b.source &&\n    a.global === b.global &&\n    a.ignoreCase === b.ignoreCase &&\n    a.multiline === b.multiline &&\n    a.unicode === b.unicode &&\n    a.sticky === b.sticky &&\n    a.lastIndex === b.lastIndex\n  );\n}\n\n/**\n * are the sets equal in value\n *\n * @param a the set to test\n * @param b the set to test against\n * @param isEqual the comparator to determine equality\n * @param meta the meta set to pass through\n * @returns are the sets equal\n */\nexport function areSetsEqual(\n  a: Set<any>,\n  b: Set<any>,\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  let isValueEqual = a.size === b.size;\n\n  if (isValueEqual && a.size) {\n    a.forEach((aValue) => {\n      if (isValueEqual) {\n        isValueEqual = false;\n\n        b.forEach((bValue) => {\n          if (!isValueEqual) {\n            isValueEqual = isEqual(aValue, bValue, meta);\n          }\n        });\n      }\n    });\n  }\n\n  return isValueEqual;\n}\n","import {\n  EqualityComparator,\n  areArraysEqual,\n  areMapsEqual,\n  areObjectsEqual,\n  areRegExpsEqual,\n  areSetsEqual,\n  isPlainObject,\n  isPromiseLike,\n  sameValueZeroEqual,\n} from './utils';\n\nconst HAS_MAP_SUPPORT = typeof Map === 'function';\nconst HAS_SET_SUPPORT = typeof Set === 'function';\n\ntype EqualityComparatorCreator = (fn: EqualityComparator) => EqualityComparator;\n\nexport function createComparator(createIsEqual?: EqualityComparatorCreator) {\n  const isEqual: EqualityComparator =\n    /* eslint-disable no-use-before-define */\n    typeof createIsEqual === 'function'\n      ? createIsEqual(comparator)\n      : comparator;\n  /* eslint-enable */\n\n  /**\n   * compare the value of the two objects and return true if they are equivalent in values\n   *\n   * @param a the value to test against\n   * @param b the value to test\n   * @param [meta] an optional meta object that is passed through to all equality test calls\n   * @returns are a and b equivalent in value\n   */\n  function comparator(a: any, b: any, meta?: any) {\n    if (a === b) {\n      return true;\n    }\n\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\n      if (isPlainObject(a) && isPlainObject(b)) {\n        return areObjectsEqual(a, b, isEqual, meta);\n      }\n\n      let aShape = Array.isArray(a);\n      let bShape = Array.isArray(b);\n\n      if (aShape || bShape) {\n        return aShape === bShape && areArraysEqual(a, b, isEqual, meta);\n      }\n\n      aShape = a instanceof Date;\n      bShape = b instanceof Date;\n\n      if (aShape || bShape) {\n        return (\n          aShape === bShape && sameValueZeroEqual(a.getTime(), b.getTime())\n        );\n      }\n\n      aShape = a instanceof RegExp;\n      bShape = b instanceof RegExp;\n\n      if (aShape || bShape) {\n        return aShape === bShape && areRegExpsEqual(a, b);\n      }\n\n      if (isPromiseLike(a) || isPromiseLike(b)) {\n        return a === b;\n      }\n\n      if (HAS_MAP_SUPPORT) {\n        aShape = a instanceof Map;\n        bShape = b instanceof Map;\n\n        if (aShape || bShape) {\n          return aShape === bShape && areMapsEqual(a, b, isEqual, meta);\n        }\n      }\n\n      if (HAS_SET_SUPPORT) {\n        aShape = a instanceof Set;\n        bShape = b instanceof Set;\n\n        if (aShape || bShape) {\n          return aShape === bShape && areSetsEqual(a, b, isEqual, meta);\n        }\n      }\n\n      return areObjectsEqual(a, b, isEqual, meta);\n    }\n\n    return a !== a && b !== b;\n  }\n\n  return comparator;\n}\n","import { createComparator } from './comparator';\nimport { createCircularEqualCreator, sameValueZeroEqual } from './utils';\n\nexport { createComparator as createCustomEqual, sameValueZeroEqual };\n\nexport const deepEqual = createComparator();\nexport const shallowEqual = createComparator(() => sameValueZeroEqual);\n\nexport const circularDeepEqual = createComparator(createCircularEqualCreator());\nexport const circularShallowEqual = createComparator(\n  createCircularEqualCreator(sameValueZeroEqual),\n);\n","import { deepEqual } from \"fast-equals\"\n\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nexport function unique<T extends Record<string, any>>(array: T[]) {\n  return array.filter((elm2, index) => array.findIndex((elm1) => deepEqual(elm1, elm2)) === index)\n}\n\nexport function getIcon(iconType: string | undefined, kindTypeGiven: string | undefined) {\n  let kindType = kindTypeGiven\n  // LSP specification: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_documentSymbol\n  // atom-languageclient mapping: https://github.com/atom/atom-languageclient/blob/485bb9d706b422456640c9070eee456ef2cf09c0/lib/adapters/outline-view-adapter.ts#L270\n\n  const iconElement = document.createElement(\"span\")\n  iconElement.classList.add(\"outline-icon\")\n\n  // if iconType given instead\n  if (kindType === undefined && iconType !== undefined) {\n    kindType = iconType\n  }\n\n  let type: string = \"ðŸž‡\"\n  if (typeof kindType === \"string\" && kindType.length > 0) {\n    let kindClass: string\n    // hasKind\n    if (kindType.indexOf(\"type-\") === 0) {\n      // supplied with type-...\n      kindClass = `${kindType}`\n      type = kindType.replace(\"type-\", \"\")\n    } else {\n      // supplied without type-\n      kindClass = `type-${kindType}`\n      type = kindType\n    }\n    iconElement.classList.add(kindClass)\n  }\n\n  iconElement.innerHTML = `<span>${type.substring(0, 3)}</span>`\n\n  return iconElement\n}\n","import { TextEditor, Point, Disposable } from \"atom\"\nimport type { OutlineTree } from \"atom-ide-base\"\nimport { scrollIntoViewIfNeeded } from \"atom-ide-base/commons-ui/scrollIntoView\"\nimport { isItemVisible } from \"atom-ide-base/commons-ui/items\"\nimport { TreeFilterer, Tree } from \"zadeh\"\nimport { unique, getIcon } from \"./utils\"\nimport { setStatus } from \"./main\"\n\nexport class OutlineView {\n  public element: HTMLDivElement\n\n  /** Contains the content of the outline which is either the status element or the list element */\n  public outlineContent: HTMLDivElement\n  /** The actual outline list element */\n  private outlineList: HTMLUListElement | undefined = undefined\n\n  /** Cache for reveal corsur */\n  private pointToElementsMap = new Map<number, Array<HTMLLIElement>>() // TODO Point to element\n  /** Cache for focused elements */\n  private focusedElms: HTMLElement[] | undefined\n  /** Cache of last rendered list used to avoid rerendering */\n  lastEntries: OutlineTree[] | undefined\n\n  private treeFilterer = new TreeFilterer<\"representativeName\" | \"plainText\", \"children\">()\n  public searchBarEditor: TextEditor | undefined\n  private searchBarEditorDisposable: Disposable | undefined\n  private selectCursorDisposable: Disposable | undefined\n\n  constructor() {\n    this.element = document.createElement(\"div\")\n    this.element.classList.add(\"atom-ide-outline\")\n\n    this.element.appendChild(makeOutlineToolbar())\n    this.element.appendChild(this.createSearchBar())\n\n    this.outlineContent = document.createElement(\"div\")\n    this.element.appendChild(this.outlineContent)\n\n    this.outlineContent.classList.add(\"outline-content\")\n  }\n\n  reset() {\n    this.searchBarEditorDisposable?.dispose()\n    this.selectCursorDisposable?.dispose()\n    this.searchBarEditor?.setText(\"\")\n  }\n\n  destroy() {\n    this.element.remove()\n  }\n\n  getElement() {\n    return this.element\n  }\n\n  // needed for Atom\n  /* eslint-disable class-methods-use-this */\n  getTitle() {\n    return \"Outline\"\n  }\n\n  getIconName() {\n    return \"list-unordered\"\n  }\n  /* eslint-enable class-methods-use-this */\n\n  /**\n   * The main function of {OutlineView} which renders the content in the outline or only update the event listeners if\n   * the outline tree hasn't changed\n   */\n  setOutline(outlineTree: OutlineTree[], editor: TextEditor, isLarge: boolean) {\n    // skip rendering if it is the same\n    // TIME 0.2-1.2ms // the check itself takes ~0.2-0.5ms, so it is better than rerendering\n    if (this.lastEntries !== undefined && hasEqualContent(outlineTree, this.lastEntries)) {\n      this.pointToElementsMap.clear() // empty revealCorsur cache\n      addEntriesOnClick(\n        this.outlineList! /* because this.lastEntries is not undefined */,\n        outlineTree,\n        editor,\n        this.pointToElementsMap,\n        0\n      )\n      return\n    } else {\n      this.lastEntries = outlineTree\n    }\n\n    this.createOutlineList(outlineTree, editor, isLarge)\n  }\n\n  /** The function to render the content in the outline */\n  createOutlineList(outlineTree: OutlineTree[], editor: TextEditor, isLarge: boolean) {\n    this.clearContent()\n\n    if (isLarge) {\n      this.outlineContent.appendChild(createLargeFileElement())\n    }\n    this.updateSearchBar(outlineTree, editor, isLarge)\n\n    this.outlineList = createOutlineList(outlineTree, editor, isLarge, this.pointToElementsMap)\n    this.outlineContent.appendChild(this.outlineList)\n  }\n\n  clearContent() {\n    this.outlineContent.innerHTML = \"\"\n    if (this.outlineList !== undefined) {\n      this.outlineList.dataset.editorRootScope = \"\"\n    }\n    this.lastEntries = undefined\n  }\n\n  updateSearchBar(outlineTree: OutlineTree[], editor: TextEditor, isLarge: boolean) {\n    this.searchBarEditorDisposable?.dispose()\n\n    // detect if representativeName exists on an entry of the tree, if it doesn't, then we use plainText\n    const firstOutlineTree = outlineTree[0]\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const dataKey = firstOutlineTree?.representativeName !== undefined ? \"representativeName\" : \"plainText\"\n\n    // @ts-ignore we check if representitiveName is undefined, and if it is, we will use plainText instead\n    this.treeFilterer.setCandidates(outlineTree, dataKey, \"children\")\n\n    this.searchBarEditorDisposable = this.searchBarEditor?.onDidStopChanging(() =>\n      this.filterOutlineTree(editor, isLarge)\n    )\n  }\n\n  createSearchBar() {\n    this.searchBarEditor = new TextEditor({ mini: true, placeholderText: \"Filter\" })\n\n    const searchBar = document.createElement(\"div\")\n    searchBar.classList.add(\"outline-searchbar\")\n\n    searchBar.appendChild(atom.views.getView(this.searchBarEditor))\n\n    return searchBar\n  }\n\n  renderLastOutlienList() {\n    if (this.outlineList !== undefined) {\n      this.clearContent()\n      this.outlineContent.appendChild(this.outlineList)\n    }\n  }\n\n  filterOutlineTree(editor: TextEditor, isLarge: boolean) {\n    // @ts-ignore\n    if (!(editor.isAlive() as boolean) || !isItemVisible(editor)) {\n      return\n    }\n\n    const text = this.searchBarEditor?.getText()\n    if (typeof text !== \"string\") {\n      this.renderLastOutlienList()\n      return\n    }\n    const query = text.trim()\n    if (query.length === 0) {\n      this.renderLastOutlienList()\n      return\n    }\n    let filterResults: Tree<\"representativeName\" | \"plainText\", \"children\">[]\n    try {\n      filterResults = this.treeFilterer.filter(query, { maxResults: 100, usePathScoring: false })\n    } catch (err) {\n      const error = err as Error\n      error.message = `Filtering failed for unkown reasons.\\n${error.message}`\n      console.error(error)\n      this.reset()\n      // Retry:\n      // @ts-ignore internal api\n      const candidates = this.treeFilterer.candidates as Tree<\"representativeName\" | \"plainText\", \"children\">[]\n      this.treeFilterer = new TreeFilterer(candidates)\n      this.updateSearchBar(candidates as unknown as OutlineTree[], editor, isLarge)\n      this.searchBarEditor?.setText(query)\n      this.filterOutlineTree(editor, isLarge)\n      return\n    }\n\n    // TODO why returns duplicates? ~0-0.2s\n    const filteredTree = unique(filterResults)\n    if (filteredTree.length === 0) {\n      return setStatus(\"noResult\")\n    }\n    const filteredOutlineList = createOutlineList(\n      filteredTree as unknown as OutlineTree[],\n      editor,\n      isLarge,\n      this.pointToElementsMap\n    )\n    this.clearContent()\n    this.outlineContent.appendChild(filteredOutlineList)\n  }\n\n  presentStatus(status: { title: string; description: string }) {\n    this.clearContent()\n\n    const statusElement = generateStatusElement(status)\n\n    this.outlineContent.appendChild(statusElement)\n  }\n\n  // callback for scrolling and highlighting the element that the cursor is on\n  selectAtCursorLine(editor: TextEditor) {\n    const cursor = editor.getLastCursor()\n\n    // skip if not visible\n    if (!isItemVisible(this)) {\n      return\n    }\n\n    if (clicked) {\n      // HACK do not scroll when the cursor has moved to a click on the outline entry\n      clicked = false\n      return\n    }\n\n    // TIME: ~0.2-0.3ms\n    // TODO use range of start and end instead of just the line number\n\n    // remove old cursorOn attribue\n    if (this.focusedElms !== undefined) {\n      for (const elm of this.focusedElms) {\n        elm.toggleAttribute(\"cursorOn\", false)\n      }\n    }\n\n    // add new cursorOn attribue\n    const cursorPoint = cursor.getBufferRow()\n    this.focusedElms = this.pointToElementsMap.get(cursorPoint)\n\n    // search in between the points\n    if (this.focusedElms === undefined) {\n      const points = this.pointToElementsMap.keys()\n      let previousPoint: number = 0\n      for (const point of points) {\n        // find the first point which has a larger point\n        if (point >= cursorPoint) {\n          const previousElms = this.pointToElementsMap.get(previousPoint)!\n          previousElms[previousElms.length - 1].classList.add(\"after-border\")\n          const currentElms = this.pointToElementsMap.get(point)!\n          this.focusedElms = [...currentElms, ...previousElms] // in reverse so the previous elms are scrolled into in the end\n          break\n        } else {\n          // update previous point for the next iteration\n          previousPoint = point\n        }\n      }\n    }\n\n    // add cursorOn and scrollInto\n    if (this.focusedElms !== undefined) {\n      for (const elm of this.focusedElms) {\n        scrollIntoViewIfNeeded(elm, true)\n        elm.toggleAttribute(\"cursorOn\", true)\n      }\n      // remove focus once cursor moved\n      this.selectCursorDisposable = editor.onDidChangeCursorPosition(() => {\n        if (this.focusedElms !== undefined) {\n          for (const elm of this.focusedElms) {\n            elm.toggleAttribute(\"cursorOn\", false)\n          }\n        }\n        this.selectCursorDisposable?.dispose()\n      })\n    }\n    // focus on the editor after finding\n    atom.views.getView(editor).focus()\n  }\n}\n\n/** Create the main outline list */\nfunction createOutlineList(\n  outlineTree: OutlineTree[],\n  editor: TextEditor,\n  isLarge: boolean,\n  pointToElementsMap: Map<number, Array<HTMLLIElement>>\n) {\n  const outlineList = document.createElement(\"ul\")\n  outlineList.dataset.editorRootScope = editor.getRootScopeDescriptor().getScopesArray().join(\" \")\n\n  const tabLength = editor.getTabLength()\n  if (typeof tabLength === \"number\") {\n    outlineList.style.setProperty(\"--editor-tab-length\", Math.max(tabLength / 2, 2).toString(10))\n  }\n  addOutlineEntries(\n    outlineList,\n    outlineTree,\n    editor,\n    /* foldInItially */ isLarge || (atom.config.get(\"atom-ide-outline.foldInitially\") as boolean),\n    0\n  )\n  // TIME 0.2-0.5m\n  addEntriesOnClick(outlineList, outlineTree, editor, pointToElementsMap, 0)\n  return outlineList\n}\n\n/** Compares the content of the two given {OutlineTree[]} It only compares the content that affects rendering */\nfunction hasEqualContent(ot1: OutlineTree[], ot2: OutlineTree[]) {\n  // simple compare\n  if (ot1 === ot2) {\n    return true\n  } else {\n    // compare length\n    const ot1Len = ot1.length\n    const ot2Len = ot2.length\n    if (ot1Len !== ot2Len) {\n      return false\n    }\n    // compare the content\n    for (let iEntry = 0; iEntry < ot1Len; iEntry++) {\n      const e1 = ot1[iEntry]\n      const e2 = ot2[iEntry]\n      if (\n        e1.representativeName !== e2.representativeName ||\n        e1.plainText !== e2.plainText ||\n        e1.kind !== e2.kind ||\n        e1.icon !== e2.icon ||\n        !hasEqualContent(e1.children, e2.children)\n      ) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\nfunction makeOutlineToolbar() {\n  const toolbar = document.createElement(\"span\")\n  toolbar.className = \"outline-toolbar\"\n\n  const revealCursorButton = document.createElement(\"button\")\n  revealCursorButton.innerHTML = \"Reveal Cursor\"\n  revealCursorButton.className = \"btn outline-btn\"\n\n  revealCursorButton.addEventListener(\"click\", () =>\n    atom.commands.dispatch(atom.views.getView(atom.workspace), \"outline:reveal-cursor\")\n  )\n\n  toolbar.appendChild(revealCursorButton)\n\n  const showCallHierarchyButton = document.createElement(\"button\")\n  showCallHierarchyButton.innerHTML = \"Show Call Hierarchy\"\n  showCallHierarchyButton.className = \"btn outline-btn\"\n\n  showCallHierarchyButton.addEventListener(\"click\", () =>\n    atom.commands.dispatch(atom.views.getView(atom.workspace), \"outline:show-call-hierarchy\")\n  )\n\n  toolbar.appendChild(showCallHierarchyButton)\n  return toolbar\n}\n\nfunction createLargeFileElement() {\n  const largeFileElement = document.createElement(\"div\")\n  largeFileElement.innerHTML = `<span class=\"large-file-mode\">Large file mode</span>`\n  return largeFileElement\n}\n\nfunction generateStatusElement(status: { title: string; description: string }) {\n  const element = document.createElement(\"div\")\n  element.className = \"status\"\n\n  const { title = \"\", description = \"\" } = status\n  element.innerHTML = `<h1>${title}</h1>\n  <span>${description}</span>`\n\n  return element\n}\n\nfunction hasChildren(entry: OutlineTree) {\n  return entry.children.length >= 1\n}\n\nfunction sortEntries(entries: OutlineTree[]) {\n  if (atom.config.get(\"atom-ide-outline.sortEntries\") as boolean) {\n    entries.sort((e1: OutlineTree, e2: OutlineTree) => {\n      const rowCompare = e1.startPosition.row - e2.startPosition.row\n      if (rowCompare === 0) {\n        // compare based on column if on the same row\n        return e1.startPosition.column - e1.startPosition.column\n      }\n      return rowCompare\n    })\n  }\n}\n\nfunction addOutlineEntries(\n  parent: HTMLUListElement,\n  entries: OutlineTree[],\n  editor: TextEditor,\n  isLarge: boolean,\n  level: number\n) {\n  // NOTE: this function is called multiple times with each update in an editor!\n  // a few of the calls is slow ~1-100ms\n\n  // TIME 0.1ms\n  sortEntries(entries)\n\n  for (const item of entries) {\n    const symbol = document.createElement(\"li\")\n\n    // symbol.setAttribute(\"level\", `${level}`); // store level in the element\n\n    // Hold an entry in a dedicated element to prevent hover conflicts - hover over an <li> tag would be cought by a parent <li>\n    // TIME: ~0-0.1ms\n    const labelElement = document.createElement(\"span\")\n\n    // TODO support item.tokenizedText\n    labelElement.innerText = item.representativeName ?? item.plainText ?? \"\"\n\n    labelElement.prepend(/* iconElement */ getIcon(item.icon, item.kind))\n\n    symbol.appendChild(labelElement)\n\n    if (hasChildren(item)) {\n      // create Child elements\n      // TIME 0-0.2ms\n      const childrenList = document.createElement(\"ul\")\n      childrenList.style.setProperty(\"--indent-level\", (level + 1).toString(10))\n      childrenList.addEventListener(\"click\", (event) => event.stopPropagation(), { passive: true })\n      symbol.appendChild(childrenList)\n\n      // fold Button\n      const foldButton = createFoldButton(childrenList, isLarge)\n      labelElement.prepend(foldButton)\n\n      // add children to outline\n      // TIME: last one of each batch is slower 0-20ms\n      addOutlineEntries(childrenList, item.children, editor, isLarge, level + 1)\n    }\n\n    // TIME: <0.1ms\n    parent.appendChild(symbol)\n  }\n}\n\n/**\n * Adds onClick to the outline entries.\n *\n * @attention The assumption about the type of Elements are added using `as HTML...`. After editing code, make sure that the types are correct\n */\nfunction addEntriesOnClick(\n  parent: HTMLUListElement,\n  entries: OutlineTree[],\n  editor: TextEditor,\n  pointToElementsMap: Map<number, Array<HTMLLIElement>>,\n  level: number\n) {\n  const entriesElements = parent.children\n  for (let iEntry = 0, len = entries.length; iEntry < len; iEntry++) {\n    const item = entries[iEntry]\n    const element = entriesElements[iEntry] as HTMLLIElement\n\n    // Cursor reposition on click\n    element.addEventListener(\"click\", () => onClickEntry(item.startPosition, editor), { passive: true })\n\n    // update the cache for selectAtCursorLine\n    addToPointToElementsMap(pointToElementsMap, item.startPosition.row, element)\n\n    if (hasChildren(item)) {\n      const chilrenRootElement = element.lastElementChild as HTMLUListElement\n      addEntriesOnClick(chilrenRootElement, item.children, editor, pointToElementsMap, level + 1)\n    }\n  }\n}\n\n/** Update start position => elements map used in `selectAtCursorLine` */\nfunction addToPointToElementsMap(\n  pointToElementsMap: Map<number, Array<HTMLLIElement>>,\n  pointStartPositionRow: number,\n  element: HTMLLIElement\n) {\n  // TIME: 0-0.2ms\n  const elms = pointToElementsMap.get(pointStartPositionRow)\n  if (elms !== undefined) {\n    elms.push(element)\n    pointToElementsMap.set(pointStartPositionRow, elms)\n  } else {\n    pointToElementsMap.set(pointStartPositionRow, [element])\n  }\n}\n\nlet clicked: boolean = false // HACK used to prevent scrolling in the outline list when an entry is clicked\n\nfunction onClickEntry(itemStartPosition: Point, editor: TextEditor) {\n  // only uses a reference to the editor and the pane and corsur are calculated on the fly\n  const editorPane = atom.workspace.paneForItem(editor)\n  if (editorPane === undefined) {\n    return\n  }\n  editorPane.activate()\n\n  editor.getCursors()[0].setBufferPosition(itemStartPosition, {\n    autoscroll: true,\n  })\n  // HACK\n  clicked = true\n}\n\nfunction createFoldButton(childrenList: HTMLUListElement, foldInitially: boolean) {\n  // TIME: ~0.1-0.5ms\n  // fold button\n  const foldButton = document.createElement(\"button\")\n\n  if (foldInitially) {\n    // collapse in large files by default\n    childrenList.hidden = true\n    foldButton.classList.add(\"outline-fold-btn\", \"collapsed\")\n  } else {\n    foldButton.classList.add(\"outline-fold-btn\", \"expanded\")\n  }\n\n  // fold listener\n  foldButton.addEventListener(\n    \"click\",\n    (event) => {\n      childrenList.hidden = !childrenList.hidden\n      if (childrenList.hidden) {\n        foldButton.classList.remove(\"expanded\")\n        foldButton.classList.add(\"collapsed\")\n      } else {\n        foldButton.classList.remove(\"collapsed\")\n        foldButton.classList.add(\"expanded\")\n      }\n      event.stopPropagation()\n    },\n    { passive: true }\n  )\n  return foldButton\n}\n","import { Disposable, TextEditor } from \"atom\"\nimport { Provider as ProviderTypes, BusySignalProvider, FindReferencesProvider } from \"../types-packages/main.d\"\n\nexport class ProviderRegistry<Provider extends Exclude<ProviderTypes, BusySignalProvider | FindReferencesProvider>> {\n  private providers: Array<Provider>\n\n  constructor() {\n    this.providers = []\n  }\n\n  addProvider(provider: Provider): Disposable {\n    const index = this.providers.findIndex((p) => provider.priority > p.priority)\n    if (index === -1) {\n      this.providers.push(provider)\n    } else {\n      this.providers.splice(index, 0, provider)\n    }\n    return new Disposable(() => {\n      this.removeProvider(provider)\n    })\n  }\n\n  removeProvider(provider: Provider): void {\n    const index = this.providers.indexOf(provider)\n    if (index !== -1) {\n      this.providers.splice(index, 1)\n    }\n  }\n\n  // TODO deprecate since there can be N providers.\n  getProviderForEditor(editor: TextEditor): Provider | null {\n    const grammar = editor.getGrammar().scopeName\n    return this.findProvider(grammar)\n  }\n\n  // TODO create an ordering or priority aware util to prefer instead.\n  getAllProvidersForEditor(editor: TextEditor): Iterable<Provider> {\n    const grammar = editor.getGrammar().scopeName\n    return this.findAllProviders(grammar)\n  }\n\n  findProvider(grammar: string): Provider | null {\n    for (const provider of this.findAllProviders(grammar)) {\n      return provider\n    }\n    return null\n  }\n\n  /** Iterates over all providers matching the grammar, in priority order. */\n  *findAllProviders(grammar: string): Iterable<Provider> {\n    for (const provider of this.providers) {\n      if (provider.grammarScopes == null || provider.grammarScopes.indexOf(grammar) !== -1) {\n        yield provider\n      }\n    }\n  }\n}\n","import { dirname } from \"path\"\nimport { promisify } from \"util\"\nimport { stat } from \"fs\"\nconst statAsync = promisify(stat)\n\nexport async function getCwd(target = \"\"): Promise<string | undefined> {\n  let cwd: string\n\n  if (target) {\n    cwd = target\n  } else {\n    const previousActiveItem = atom.workspace.getActivePaneItem() as { getPath?: () => string }\n    cwd = previousActiveItem?.getPath?.() as string\n    if (cwd) {\n      const dir = atom.project.relativizePath(cwd)[0]\n      if (dir) {\n        // Use project paths whenever they are available by default.\n        return dir\n      }\n    }\n  }\n\n  try {\n    if (cwd) {\n      // Otherwise, if the path exists on the local file system, use the\n      // path or parent directory as appropriate.\n      const stats = await statAsync(cwd)\n      if (stats.isDirectory()) {\n        return cwd\n      }\n\n      cwd = dirname(cwd)\n      const dirStats = await statAsync(cwd)\n      if (dirStats.isDirectory()) {\n        return cwd\n      }\n    }\n  } catch {\n    //fail silently\n  }\n\n  cwd = atom.project.getPaths()[0]\n  // no project paths\n  return cwd\n}\n","import { TextEditor, TextEditorComponent, TextBuffer, Range, Point } from \"atom\"\nimport invariant from \"assert\"\n\n/**\n * Finds the word at the position. You can either provide a word regex yourself, or have Atom use the word regex in\n * force at the scopes at that position, in which case it uses the optional includeNonWordCharacters, default true. (I\n * know that's a weird default but it follows Atom's convention...)\n */\nexport function wordAtPosition(\n  editor: TextEditor,\n  position: Point,\n  wordRegex?: RegExp | { includeNonWordCharacters: boolean }\n): { wordMatch: Array<string>; range: Range } | null {\n  let wordRegex_\n  if (wordRegex instanceof RegExp) {\n    wordRegex_ = wordRegex\n  } else {\n    // What is the word regex associated with the position? We'd like to use\n    // Cursor.wordRegExp, except that function gets the regex associated\n    // with the editor's current cursor while we want the regex associated with\n    // the specific position. So we re-implement it ourselves...\n    // @ts-ignore: https://github.com/atom/atom/blob/aa3c34bedb361e09a5068dce9620b460a20ca3fb/src/text-editor.js#L5032\n    const nonWordChars: string = editor.getNonWordCharacters(position)\n    const escaped = nonWordChars.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n    // We copied this escaping regex from Cursor.wordRegexp, rather than\n    // using the library function 'escapeStringRegExp'. That's because the\n    // library function doesn't escape the hyphen character and so is\n    // unsuitable for use inside a range.\n    let r = `^[\\t ]*$|[^\\\\s${escaped}]+`\n    if (wordRegex == null || wordRegex.includeNonWordCharacters) {\n      r += `|[${escaped}]+`\n    }\n    wordRegex_ = new RegExp(r, \"g\")\n  }\n  return wordAtPositionFromBuffer(editor.getBuffer(), position, wordRegex_)\n}\n\n/**\n * Gets the trimmed range from a given range, i.e. moves the start and end points to the first and last non-whitespace\n * characters (or specified regex) within the range respectively.\n *\n * @param editor The editor containing the range\n * @param rangeToTrim The range to trim\n * @param stopRegex Stop trimming when the first match is found for this regex, defaults to first non-whitespace character\n * @returns Range the trimmed range\n */\nexport function trimRange(editor: TextEditor, rangeToTrim: Range, stopRegex: RegExp = /\\S/): Range {\n  const buffer = editor.getBuffer()\n  let { start, end } = rangeToTrim\n  buffer.scanInRange(stopRegex, rangeToTrim, ({ range, stop }) => {\n    start = range.start\n    stop()\n  })\n  buffer.backwardsScanInRange(stopRegex, rangeToTrim, ({ range, stop }) => {\n    end = range.end\n    stop()\n  })\n  return new Range(start, end)\n}\n\nfunction getSingleWordAtPosition(editor: TextEditor, position: Point): string | null {\n  const match = wordAtPosition(editor, position)\n  // We should only receive a single identifier from a single point.\n  if (match == null || match.wordMatch.length !== 1) {\n    return null\n  }\n\n  return match.wordMatch[0]\n}\n\n/**\n * Gets the word being right-clicked on in a MouseEvent. A good use case for this is performing an action on a word from\n * a context menu.\n *\n * @param editor The editor containing the word where the MouseEvent occurred from\n * @param event The MouseEvent containing the screen position of the click\n */\nexport function getWordFromMouseEvent(editor: TextEditor, event: MouseEvent): string | null {\n  // We can't immediately get the identifier right-clicked on from\n  // the MouseEvent. Using its target element content would work in\n  // some cases but wouldn't work if there was additional content\n  // in the same element, such as in a comment.\n  // @ts-ignore: https://github.com/atom/atom/blob/aa3c34bedb361e09a5068dce9620b460a20ca3fb/src/text-editor.js#L5075\n  const component: TextEditorComponent = editor.getElement().component\n  invariant(component)\n  // This solution doesn't feel ideal but it is the way hyperclick does it.\n  const point = component.screenPositionForMouseEvent(event)\n  return getSingleWordAtPosition(editor, point)\n}\n\n/**\n * Attempts to get a word from the last selection or cursor. A good use case for this is performing an action on an\n * 'active' word after a command is triggered via a keybinding.\n *\n * @param editor The editor containing the 'active' word when the keybinding is triggered\n */\nexport function getWordFromCursorOrSelection(editor: TextEditor): string | null {\n  const selection = editor.getSelectedText()\n  if (selection && selection.length > 0) {\n    return selection\n  }\n\n  // There was no selection so we can go ahead and try the cursor position.\n  const point = editor.getCursorScreenPosition()\n  return getSingleWordAtPosition(editor, point)\n}\n\nexport function wordAtPositionFromBuffer(\n  buffer: TextBuffer,\n  position: Point,\n  wordRegex: RegExp\n): { wordMatch: Array<string>; range: Range } | null {\n  const { row, column } = position\n  const rowRange = buffer.rangeForRow(row)\n  let matchData: { match: Array<string>; range: Range } | null\n  // Extract the expression from the row text.\n  buffer.scanInRange(wordRegex, rowRange, (data) => {\n    const { range } = data\n    if (range.start.isLessThanOrEqual(position) && range.end.isGreaterThan(position)) {\n      matchData = data\n    }\n    // Stop the scan if the scanner has passed our position.\n    if (range.end.column > column) {\n      data.stop()\n    }\n  })\n  // @ts-ignore (it is assigned above)\n  if (matchData) {\n    return {\n      wordMatch: matchData.match,\n      range: matchData.range,\n    }\n  } else {\n    return null\n  }\n}\n\n// Matches a regex on the text of the line ending at endPosition.\n// regex should end with a '$'.\n// Useful for autocomplete.\nexport function matchRegexEndingAt(buffer: TextBuffer, endPosition: Point, regex: RegExp): string | null {\n  const line = buffer.getTextInRange([[endPosition.row, 0], endPosition])\n  const match = regex.exec(line)\n  return match == null ? null : match[0]\n}\n\nexport function isPositionInRange(position: Point, range: Range | Array<Range>): boolean {\n  return Array.isArray(range) ? range.some((r) => r.containsPoint(position)) : range.containsPoint(position)\n}\n","/** Show a JavaScript Error as an atom notifications */\nexport function notifyError(e: Error) {\n  atom.notifications.addError(e.name, {\n    stack: e.stack,\n    detail: e.message,\n  })\n}\n","import { TextEditor } from \"atom\"\n\n/**\n * Find if an editor's largeness based on the given threashold\n *\n * @param editor\n * @param largeLineCount LineCountIfLarge threashold\n * @param longLineLength LineLengthIfLong threashold\n * @returns The largness score if editor is large. Otherwise it returns 0 (a small file)\n */\nexport function largeness(\n  editor: TextEditor,\n  largeLineCount: number = atom.config.get(\"atom-ide-base.largeLineCount\") || 4000,\n  longLineLength: number = atom.config.get(\"atom-ide-base.longLineLength\") || 4000\n) {\n  const lineCount = lineCountIfLarge(editor, largeLineCount)\n  if (lineCount !== 0) {\n    return lineCount\n  }\n  const longLine = lineLengthIfLong(editor, longLineLength)\n  if (longLine !== 0) {\n    return longLine\n  }\n  return 0 // small file\n}\n\n/**\n * Find if an editor has a line that is longer than the given threashold\n *\n * @param editor\n * @param threashold LargeLineCount threashold\n * @returns The line count if it is larger than threashold. Otherwise it returns 0 (a small file)\n */\nexport function lineCountIfLarge(editor: TextEditor, threashold: number) {\n  // @ts-ignore\n  if (editor.largeFileMode) {\n    return 100000\n  }\n  const lineCount = editor.getLineCount()\n  if (lineCount >= threashold) {\n    return lineCount\n  }\n  return 0 // small file\n}\n\n/**\n * Find if an editor has a line that is longer than the given threashold\n *\n * @param editor\n * @param threashold LineLengthForRow threashold\n * @param lineCount Count up to this line. Default is {editor.getLineCount()}\n * @returns The first line length that has a length larger than threashold. If no line is found, it returns 0\n */\nexport function lineLengthIfLong(editor: TextEditor, threashold: number, lineCount: number = editor.getLineCount()) {\n  const buffer = editor.getBuffer()\n  for (let i = 0, len = lineCount; i < len; i++) {\n    const lineLength = buffer.lineLengthForRow(i)\n    if (lineLength > threashold) {\n      return lineLength\n    }\n  }\n  return 0 // small file\n}\n","export * from \"./getCwd\"\nexport * from \"./ProviderRegistry\"\nexport * from \"./range\"\nexport * from \"./errors\"\nexport * from \"./editor-largeness\"\n","export const statuses = {\n  noEditor: {\n    title: \"Outline is unavailable.\",\n    description: \"Open a text editor.\",\n  },\n  noProvider: {\n    title: \"Provider is unavailable\",\n    description:\n      \"Looks like a provider for this type of file is not available. Check if a relevant IDE language package is installed and has outline support, or try adding one from Atom's package registry (e.g.: atom-ide-javascript, atom-typescript, ide-python, ide-rust, ide-css, ide-json).\",\n  },\n  noResult: {\n    title: \"No result was found.\",\n    description: \"The Outline could not found the text you entered in the filter bar.\",\n  },\n}\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n","var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","// Define the Pane item used for CallHierarchy\n\nimport { CompositeDisposable } from \"atom\"\nimport type { Disposable, Point, Range, TextEditor } from \"atom\"\nimport type { ProviderRegistry } from \"atom-ide-base/commons-atom/ProviderRegistry\"\nimport type { CallHierarchy, CallHierarchyProvider, CallHierarchyType } from \"atom-ide-base\"\nimport debounce from \"lodash/debounce\"\nimport statuses from \"./statuses.json\"\nimport { getIcon } from \"../utils\"\n\ntype statusKey = keyof typeof statuses\n\n/** HTMLElement for the call-hierarchy tab */\nexport class CallHierarchyView extends HTMLElement {\n  #subscriptions = new CompositeDisposable()\n\n  /** Subscription to observe editor cursor movement */\n  #editorSubscriptions: Disposable | undefined\n\n  #providerRegistry: ProviderRegistry<CallHierarchyProvider>\n\n  /** Element for outputting results */\n  #outputElement: HTMLDivElement\n\n  /** Whether to display incoming or outgoing */\n  #currentType: CallHierarchyType\n\n  /** Time to debounce the timing of display updates */\n  #debounceWaitTime = 300\n\n  /**\n   * Status of currently displayed content\n   *\n   * - Valid: there is data obtained from the provider\n   * - NoEditor: editor not found\n   * - NoProvider: provider not found\n   * - NoResult: provider returns null or empty array (cursor is above something other than function)\n   */\n  #status: statusKey | \"valid\" | undefined\n\n  /** Whether the tab has already been closed */\n  destroyed = false\n\n  /** Needed for Atom */\n  getTitle = () => \"Call Hierarchy\"\n  /** Needed for Atom */\n  getIconName = () => \"link\"\n\n  /** Determine the type of data to display */\n  static getStatus(data: CallHierarchy<CallHierarchyType> | statusKey | null | undefined): statusKey | \"valid\" {\n    if (typeof data === \"string\") {\n      return data\n    }\n    if (!data || data.data.length === 0) {\n      return \"noResult\"\n    }\n    return \"valid\"\n  }\n\n  /** Called when the call-hierarchy tab is opened */\n  constructor({ providerRegistry }: { providerRegistry: ProviderRegistry<CallHierarchyProvider> }) {\n    super()\n    this.#providerRegistry = providerRegistry\n    const headerElement = this.appendChild(document.createElement(\"div\"))\n    headerElement.innerHTML = `\n      <div class=\"icon icon-alignment-align\">Incoming</div>\n      <div class=\"icon icon-alignment-aligned-to\">Outgoing</div>\n    `\n    headerElement.addEventListener(\"click\", () => this.#toggleCurrentType())\n    this.#outputElement = this.appendChild(document.createElement(\"div\"))\n    this.#currentType = \"incoming\"\n    this.setAttribute(\"current-type\", \"incoming\")\n    // show call hierarchy when cursor position changes\n    const debouncedShowCallHierarchy = debounce(this.showCallHierarchy.bind(this), this.#debounceWaitTime)\n    this.#subscriptions.add(\n      atom.workspace.observeActiveTextEditor((editor) => {\n        this.#editorSubscriptions?.dispose()\n        this.#editorSubscriptions = editor?.onDidChangeCursorPosition((event) => {\n          debouncedShowCallHierarchy(editor, event.newBufferPosition)\n        })\n        this.showCallHierarchy(editor)\n      })\n    )\n  }\n\n  /** Toogle between incoming and outgoing displays */\n  #toggleCurrentType = () => {\n    this.#currentType = this.#currentType === \"incoming\" ? \"outgoing\" : \"incoming\"\n    this.setAttribute(\"current-type\", this.#currentType)\n    this.showCallHierarchy()\n  }\n\n  /** Show call hierarchy for {editor} and {point} */\n  async showCallHierarchy(editor?: TextEditor, point?: Point) {\n    if (this.destroyed) {\n      return\n    }\n    const targetEditor = editor ?? atom.workspace.getActiveTextEditor()\n    if (!targetEditor) {\n      // display a message for when there is no editor\n      await this.#updateCallHierarchyView(\"noEditor\")\n      return\n    }\n    const targetPoint = point ?? targetEditor.getCursorBufferPosition()\n    const provider = this.#providerRegistry.getProviderForEditor(targetEditor)\n    if (!provider) {\n      // display a message for when there is no provider\n      await this.#updateCallHierarchyView(\"noProvider\")\n      return\n    }\n    // update display with new data\n    await this.#updateCallHierarchyView(\n      await (this.#currentType === \"incoming\"\n        ? provider.getIncomingCallHierarchy(targetEditor, targetPoint)\n        : provider.getOutgoingCallHierarchy(targetEditor, targetPoint))\n    )\n  }\n\n  /** Show call hierarchy for {newData} */\n  #updateCallHierarchyView = async (newData: CallHierarchy<CallHierarchyType> | statusKey | null | undefined) => {\n    const prevStatus = this.#status\n    const currentStatus = (this.#status = CallHierarchyView.getStatus(newData))\n    if (currentStatus === \"valid\") {\n      // update display when there is new data\n      this.#outputElement.innerHTML = \"\"\n      // type of `newData` must be `CallHierarchy` because status is valid\n      const item = new CallHierarchyViewItem(newData as CallHierarchy<CallHierarchyType>)\n      this.#outputElement.appendChild(item)\n      // unfold the first hierarchy\n      await item.toggleAllItem()\n      return\n    }\n    if (prevStatus === currentStatus) {\n      // Do not update if the displayed content does not change\n      return\n    }\n    // update display with new status message when status is noEditor, noProvider or noResult\n    this.#outputElement.innerHTML = \"\"\n    const item = new CallHierarchyViewStatusItem(statuses[currentStatus])\n    this.#outputElement.appendChild(item)\n  }\n\n  /** Called when the call-hierarchy tab is closed */\n  destroy() {\n    this.innerHTML = \"\"\n    this.#editorSubscriptions?.dispose()\n    this.#subscriptions.dispose()\n    this.destroyed = true\n  }\n}\ncustomElements.define(\"atom-ide-outline-call-hierarchy-view\", CallHierarchyView)\n\n/** HTMLElement for the call-hierarchy item */\nclass CallHierarchyViewItem<T extends CallHierarchyType> extends HTMLElement {\n  #callHierarchy: CallHierarchy<T> | undefined\n  #childCallHierarchies: Promise<CallHierarchy<T> | undefined>[]\n\n  #dblclickWaitTime = 300\n\n  /** Whether {callHierarchy} data is undefined or empty array */\n  static isEmpty(callHierarchy: CallHierarchy<CallHierarchyType> | undefined): callHierarchy is undefined {\n    return !callHierarchy || callHierarchy.data.length === 0\n  }\n\n  constructor(callHierarchy: CallHierarchy<T>) {\n    super()\n    this.#callHierarchy = callHierarchy\n    this.#childCallHierarchies = this.#callHierarchy.data.map((_item, i) => callHierarchy.itemAt(i))\n    this.append(\n      ...this.#callHierarchy.data.map((item, i) => {\n        const itemEl = document.createElement(\"div\")\n        itemEl.setAttribute(\"title\", item.path)\n        itemEl.innerHTML = `\n          <div class=\"icon icon-chevron-right\">\n            <div>\n              <span>${escapeHTML(item.name)}</span>\n              <span class=\"detail\">${escapeHTML(item.detail ? ` - ${item.detail}` : \"\")}</span>\n              ${item.tags.map((str) => `<span class=\"tag-${escapeHTML(str)}\">${escapeHTML(str)}</span>`).join(\"\")}\n            </div>\n          </div>\n        `\n        itemEl\n          .querySelector(\":scope>div>div\")\n          ?.insertAdjacentElement(\"afterbegin\", getIcon(item.icon ?? undefined, undefined))\n        // click to fold or unfold child items\n        let isDblclick = false\n        itemEl.querySelector(\":scope>div\")?.addEventListener(\n          \"click\",\n          (e) => {\n            e.stopPropagation()\n            if (isDblclick && this.#callHierarchy) {\n              // double-click to jump to the document\n              this.#showDocument(this.#callHierarchy.data[i])\n              return\n            }\n            // single-click to toggle the display of item\n            this.toggleItemAt(i)\n            // enable double click\n            window.setTimeout(() => (isDblclick = false), this.#dblclickWaitTime)\n            isDblclick = true\n          },\n          false\n        )\n        // enable toggle button if child element can be displayed\n        this.#childCallHierarchies[i].then((childCallHierarchy) => {\n          if (!CallHierarchyViewItem.isEmpty(childCallHierarchy)) {\n            itemEl.classList.add(\"call-hierarchy-exist-child-data\")\n          }\n        })\n        return itemEl\n      })\n    )\n  }\n\n  /** Toggle the display of the {i}-th item */\n  async toggleItemAt(i: number) {\n    const itemEl = this.querySelectorAll<HTMLLIElement>(\":scope>div\")[i]\n    const titleEl = itemEl.querySelector<HTMLDivElement>(\":scope>div\")\n    const childEl = itemEl.querySelector<CallHierarchyViewItem<T>>(\"atom-ide-outline-call-hierarchy-item\")\n    if (childEl) {\n      if (childEl.style.display !== \"none\") {\n        // hide if visible\n        childEl.style.display = \"none\"\n        titleEl?.classList.replace(\"icon-chevron-down\", \"icon-chevron-right\")\n      } else {\n        // show if hidden\n        childEl.style.display = \"\"\n        titleEl?.classList.replace(\"icon-chevron-right\", \"icon-chevron-down\")\n      }\n    } else {\n      const childCallHierarchy = await this.#childCallHierarchies[i]\n      if (!CallHierarchyViewItem.isEmpty(childCallHierarchy)) {\n        // create element if there is no data\n        itemEl.appendChild(new CallHierarchyViewItem(childCallHierarchy))\n        titleEl?.classList.replace(\"icon-chevron-right\", \"icon-chevron-down\")\n      }\n    }\n  }\n\n  /** Toggle the display of all item */\n  async toggleAllItem() {\n    const dataLen = this.#callHierarchy?.data.length ?? 0\n    await Promise.all([...Array(dataLen).keys()].map((i) => this.toggleItemAt(i)))\n  }\n\n  /** Show document for {range} and {path}, and select {selectionRange} */\n  #showDocument = ({\n    path,\n    range: {\n      start: { row, column },\n    },\n    selectionRange,\n  }: {\n    path: string\n    range: Range\n    selectionRange: Range\n  }) => {\n    const editor = atom.workspace.getActiveTextEditor()\n    if (editor?.getPath() === path) {\n      editor.setCursorBufferPosition([row, column])\n      editor.scrollToBufferPosition([row, column], { center: true })\n      editor.setSelectedBufferRange(selectionRange)\n    } else {\n      atom.workspace\n        .open(path, {\n          initialLine: row,\n          initialColumn: column,\n          searchAllPanes: true,\n          activatePane: true,\n          activateItem: true,\n        })\n        .then((editor: any) => editor?.setSelectedBufferRange(selectionRange))\n    }\n  }\n}\ncustomElements.define(\"atom-ide-outline-call-hierarchy-item\", CallHierarchyViewItem)\n\n/** Create a message when there is nothing to display. */\nclass CallHierarchyViewStatusItem extends HTMLElement {\n  constructor({ title, description }: { title: string; description: string }) {\n    super()\n    this.innerHTML = `\n      <h1>${escapeHTML(title)}</h1>\n      <span>${escapeHTML(description)}</span>\n    `\n  }\n}\ncustomElements.define(\"atom-ide-outline-call-hierarchy-status-item\", CallHierarchyViewStatusItem)\n\nfunction escapeHTML(str: string): string {\n  return str.replace(\n    /[\"&'<>`]/g,\n    (match) =>\n      ({\n        \"&\": \"&amp;\",\n        \"'\": \"&#x27;\",\n        \"`\": \"&#x60;\",\n        '\"': \"&quot;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n      }[match] as string)\n  )\n}\n","import type { Pane } from \"atom\"\n\n/** Handles the operation of opening and closing tabs. */\nexport class TabHandler<T extends object> {\n  /** Returns the dock where the tab should be created. */\n  static #getDefaultDock() {\n    // If want to change the location of the new tab, change the code here.\n    return atom.workspace.getRightDock()\n  }\n  /** It is possible that the tab does not exist even if the item is not undefined, as the tab may be closed manually. */\n  item: T | undefined\n  #createItem: () => T\n  constructor({\n    createItem,\n  }: {\n    /** Function called when creating a tab. Should return the pane item you want to add to the tab. */\n    createItem: () => T\n  }) {\n    this.#createItem = createItem\n  }\n  /**\n   * Toggle the tab. If the tab exists, it will be deleted. If the tab is open but hidden, the tab will be brought to\n   * the front. If the tab does not exist, it will be created.\n   */\n  toggle() {\n    const { state, targetPane } = this.#getState()\n    if (state === \"hidden\") {\n      this.#display({ targetPane })\n    } else if (state === \"noItem\") {\n      this.#create({ targetPane })\n    } else {\n      this.#destroy({ targetPane })\n    }\n  }\n  /**\n   * Show the tab. If the tab is open but hidden, the tab will be brought to the front. If the tab does not exist, it\n   * will be created.\n   */\n  show() {\n    const { state, targetPane } = this.#getState()\n    if (state === \"hidden\") {\n      this.#display({ targetPane })\n    } else if (state === \"noItem\") {\n      this.#create({ targetPane })\n    }\n  }\n  /** Delete the tab. If the tab exists, it will be deleted. */\n  delete() {\n    const targetPane = this.item && atom.workspace.paneForItem(this.item)\n    if (targetPane) {\n      this.#destroy({ targetPane })\n    }\n  }\n  /** Display the hidden tab at target pane. */\n  #display({ targetPane }: { targetPane: Pane }) {\n    if (this.item) {\n      targetPane.activateItem(this.item)\n    }\n    const dock = atom.workspace.getPaneContainers().find((v) => v.getPanes().includes(targetPane))\n    if (dock && \"show\" in dock) {\n      dock.show()\n    }\n  }\n  /** Create the new tab at target pane. */\n  #create({ targetPane }: { targetPane: Pane }) {\n    this.item = this.#createItem()\n    targetPane.addItem(this.item)\n    targetPane.activateItem(this.item)\n    TabHandler.#getDefaultDock().show()\n  }\n  /** Destroy the tab from target pane. */\n  #destroy({ targetPane }: { targetPane: Pane }) {\n    if (this.item) {\n      targetPane.destroyItem(this.item)\n    }\n  }\n  /** Get the state of the tab. */\n  #getState() {\n    const pane = this.item && atom.workspace.paneForItem(this.item)\n    if (pane) {\n      if (\n        pane.getActiveItem() === this.item &&\n        // @ts-ignore (getVisiblePanes is not includes typedef)\n        atom.workspace.getVisiblePanes().includes(pane)\n      ) {\n        return { state: \"visible\", targetPane: pane } as const\n      } else {\n        return { state: \"hidden\", targetPane: pane } as const\n      }\n    } else {\n      return {\n        state: \"noItem\",\n        targetPane: TabHandler.#getDefaultDock().getActivePane(),\n      } as const\n    }\n  }\n}\n","import { CompositeDisposable } from \"atom\"\nimport type { Disposable } from \"atom\"\nimport { ProviderRegistry } from \"atom-ide-base/commons-atom/ProviderRegistry\"\nimport type { CallHierarchyProvider } from \"atom-ide-base\"\n\nimport { CallHierarchyView } from \"./call-hierarchy-view\"\nimport { TabHandler } from \"./tab-handler\"\n\nconst providerRegistry = new ProviderRegistry<CallHierarchyProvider>()\nconst subscriptions = new CompositeDisposable()\nconst callHierarchyTab = new TabHandler({\n  createItem: () => new CallHierarchyView({ providerRegistry }),\n})\n\nexport function activate() {\n  subscriptions.add(\n    atom.commands.add(\"atom-workspace\", \"outline:toggle-call-hierarchy\", () => callHierarchyTab.toggle()),\n    atom.commands.add(\"atom-workspace\", \"outline:show-call-hierarchy\", () => callHierarchyTab.show())\n  )\n}\n\nexport function deactivate() {\n  subscriptions.dispose()\n  callHierarchyTab.delete()\n}\n\nexport function consumeCallHierarchyProvider(provider: CallHierarchyProvider): Disposable {\n  const providerDisposer = providerRegistry.addProvider(provider)\n  subscriptions.add(providerDisposer)\n  callHierarchyTab.item?.showCallHierarchy()\n  return providerDisposer\n}\n","import { CompositeDisposable, TextEditor } from \"atom\"\nimport type { Disposable } from \"atom\"\nimport { OutlineView } from \"./outlineView\"\nimport type { OutlineProvider } from \"atom-ide-base\"\nimport { ProviderRegistry } from \"atom-ide-base/commons-atom/ProviderRegistry\"\nimport { notifyError, largeness as editorLargeness } from \"atom-ide-base/commons-atom\"\nimport { isItemVisible } from \"atom-ide-base/commons-ui/items\"\n\nexport { statuses } from \"./statuses\" // for spec\nimport { statuses } from \"./statuses\"\nimport debounce from \"lodash/debounce\"\n\nexport { consumeCallHierarchyProvider } from \"./call-hierarchy/main\"\nimport * as CallHierarchy from \"./call-hierarchy/main\"\n\nconst subscriptions = new CompositeDisposable()\n\nlet view: OutlineView | undefined\nexport const outlineProviderRegistry = new ProviderRegistry<OutlineProvider>()\n\n// let busySignalProvider: BusySignalProvider | undefined // service might be consumed late\n\nexport function activate() {\n  CallHierarchy.activate()\n  addCommands()\n  addObservers()\n  if (atom.config.get(\"atom-ide-outline.initialDisplay\") as boolean) {\n    // initially show outline pane\n    toggleOutlineView().catch((e: Error) => {\n      notifyError(e)\n    })\n  }\n}\n\nfunction addCommands() {\n  subscriptions.add(\n    /* outlineToggle */ atom.commands.add(\"atom-workspace\", \"outline:toggle\", toggleOutlineView),\n    /* revealCursor */ atom.commands.add(\"atom-workspace\", \"outline:reveal-cursor\", revealCursor)\n  )\n}\n\nfunction addObservers() {\n  // if the active text editor changed (switched to another editor), then call editorChanged function\n  subscriptions.add(atom.workspace.onDidChangeActiveTextEditor(editorChanged))\n}\n\nexport function deactivate() {\n  CallHierarchy.deactivate()\n  onEditorChangedDisposable?.dispose()\n  subscriptions.dispose()\n  view?.destroy()\n  view = undefined\n}\n\n// export function consumeSignal(registry: BusySignalRegistry) {\n//   busySignalProvider = registry.create()\n//   subscriptions.add(busySignalProvider)\n// }\n\nexport function consumeOutlineProvider(provider: OutlineProvider): Disposable {\n  const prividerDisposable = outlineProviderRegistry.addProvider(provider)\n  subscriptions.add(/*  providerRegistryEntry */ prividerDisposable)\n\n  // NOTE Generate (try) an outline after obtaining a provider for the current active editor\n  // this initial outline is always rendered no matter if it is visible or not,\n  // this is because we can't track if the outline tab becomes visible suddenly later,\n  // or if the editor changes later once outline is visible\n  // so we need to have an outline for the current editor\n  // the following updates rely on the visibility\n  getOutline().catch((err) => {\n    throw err\n  })\n  return prividerDisposable\n}\n\n// disposables returned inside onEditorChangedDisposable\nlet onEditorChangedDisposable: CompositeDisposable | undefined = undefined\n\n/**\n * How long to wait for the new changes before updating the outline. A high number will increase the responsiveness of\n * the text editor in large files.\n */\nfunction getDebounceTime(editor: TextEditor) {\n  const largeness = editorLargeness(editor)\n  return Math.max(largeness / 4, 300) // 1/4 of the line count\n}\n\nasync function editorChanged(editor?: TextEditor) {\n  if (editor === undefined) {\n    return\n  }\n  // dispose the old subscriptions\n  onEditorChangedDisposable?.dispose()\n  onEditorChangedDisposable = new CompositeDisposable() // we can't reuse the CompositeDisposable!\n\n  // NOTE initial outline is always rendered no matter if it is visible or not,\n  // this is because we can't track if the outline tab becomes visible suddenly,\n  // so we always need to show the outline for the correct file\n  // the following updates rely on the visibility\n  await getOutline(editor)\n\n  const updateDebounceTime = getDebounceTime(editor)\n\n  const doubouncedGetOutline = debounce(\n    getOutlintIfVisible as (textEditor: TextEditor) => Promise<void>,\n    updateDebounceTime\n  )\n\n  onEditorChangedDisposable.add(\n    // update the outline if editor stops changing\n    editor.onDidStopChanging(async () => {\n      await doubouncedGetOutline(editor)\n    }),\n\n    // clean up if the editor editor is closed\n    editor.onDidDestroy(() => {\n      setStatus(\"noEditor\")\n    })\n  )\n}\n\nexport function revealCursor() {\n  const editor = atom.workspace.getActiveTextEditor()\n  if (editor === undefined) {\n    return\n  }\n\n  // following cursor disposable\n  if (view !== undefined) {\n    view.selectAtCursorLine(editor)\n  }\n}\n\nexport async function toggleOutlineView() {\n  if (view === undefined) {\n    view = new OutlineView() // create outline pane\n  }\n  const outlinePane = atom.workspace.paneForItem(view)\n  if (outlinePane) {\n    await outlinePane.destroyItem(view)\n    return\n  }\n\n  const rightDock = atom.workspace.getRightDock()\n  const [pane] = rightDock.getPanes()\n\n  pane.addItem(view)\n  pane.activateItem(view)\n\n  rightDock.show()\n\n  // Trigger an editor change whenever an outline is toggeled.\n  try {\n    await editorChanged(atom.workspace.getActiveTextEditor())\n  } catch (e) {\n    notifyError(e as Error)\n  }\n}\n\nfunction getOutlintIfVisible(editor = atom.workspace.getActiveTextEditor()) {\n  // if outline is not visible return\n  if (!isItemVisible(view)) {\n    return\n  }\n  return getOutline(editor)\n}\n\nexport async function getOutline(editor = atom.workspace.getActiveTextEditor()) {\n  if (view === undefined) {\n    view = new OutlineView() // create outline pane\n  } else {\n    view.reset()\n  }\n  // editor\n  if (editor === undefined) {\n    return setStatus(\"noEditor\")\n  }\n\n  // provider\n  const provider = outlineProviderRegistry.getProviderForEditor(editor)\n\n  if (!provider) {\n    return setStatus(\"noProvider\")\n  }\n\n  // const busySignalID = `Outline: ${editor.getPath()}`\n  // busySignalProvider?.add(busySignalID)\n\n  const outline = await provider.getOutline(editor)\n  view.setOutline(outline?.outlineTrees ?? [], editor, Boolean(editorLargeness(editor as TextEditor)))\n\n  // busySignalProvider?.remove(busySignalID)\n}\n\nexport function setStatus(id: \"noEditor\" | \"noProvider\" | \"noResult\") {\n  view?.presentStatus(statuses[id])\n}\n\nexport { default as config } from \"./config.json\"\n"],"names":["el","alignToTop","scrollTops","getScrollTops","scrollIntoView","restoreOverflowHiddenScrollTops","center","scrollIntoViewIfNeeded","el_","Map","set","scrollTop","parentElement","forEach","isOverflowHidden","overflowStyle","style","overflow","getComputedStyle","item","element","getItemElement","undefined","isElementVisible","paneContainer","atom","workspace","paneContainerForItem","isVisible","HTMLElement","display","hidden","offsetHeight","getElement","HAS_WEAKSET_SUPPORT","WeakSet","keys","Object","sameValueZeroEqual","a","b","isPlainObject","value","constructor","isPromiseLike","then","isReactElement","$$typeof","getNewCacheFallback","values","add","push","has","indexOf","getNewCache","createCircularEqualCreator","isEqual","comparator","_comparator","cache","isCacheableA","isCacheableB","hasA","hasB","hasOwnProperty","Function","prototype","bind","call","areObjectsEqual","meta","keysA","index","length","key","reactElementA","reactElementB","HAS_MAP_SUPPORT","HAS_SET_SUPPORT","Set","createComparator","createIsEqual","aShape","Array","isArray","bShape","areArraysEqual","Date","getTime","RegExp","source","global","ignoreCase","multiline","unicode","sticky","lastIndex","areRegExpsEqual","isValueEqual","size","aValue","aKey","bValue","bKey","areMapsEqual","areSetsEqual","deepEqual","getIcon","iconType","kindTypeGiven","kindType","iconElement","document","createElement","classList","type","kindClass","replace","innerHTML","substring","OutlineView","this","TreeFilterer","appendChild","toolbar","className","revealCursorButton","addEventListener","commands","dispatch","views","getView","showCallHierarchyButton","makeOutlineToolbar","createSearchBar","outlineContent","reset","searchBarEditorDisposable","dispose","selectCursorDisposable","searchBarEditor","setText","destroy","remove","getTitle","getIconName","setOutline","outlineTree","editor","isLarge","lastEntries","hasEqualContent","pointToElementsMap","clear","addEntriesOnClick","outlineList","createOutlineList","clearContent","largeFileElement","createLargeFileElement","updateSearchBar","dataset","editorRootScope","firstOutlineTree","dataKey","representativeName","treeFilterer","setCandidates","onDidStopChanging","filterOutlineTree","TextEditor","mini","placeholderText","searchBar","renderLastOutlienList","isAlive","isItemVisible","text","getText","query","trim","filterResults","filter","maxResults","usePathScoring","err","error","message","console","candidates","filteredTree","array","elm2","findIndex","elm1","setStatus","filteredOutlineList","presentStatus","status","statusElement","title","description","generateStatusElement","selectAtCursorLine","cursor","getLastCursor","clicked","focusedElms","elm","toggleAttribute","cursorPoint","getBufferRow","get","points","previousPoint","point","previousElms","currentElms","onDidChangeCursorPosition","focus","getRootScopeDescriptor","getScopesArray","join","tabLength","getTabLength","setProperty","Math","max","toString","addOutlineEntries","config","ot1","ot2","ot1Len","iEntry","e1","e2","plainText","kind","icon","children","hasChildren","entry","parent","entries","level","sort","rowCompare","startPosition","row","column","sortEntries","symbol","labelElement","innerText","prepend","childrenList","event","stopPropagation","passive","foldButton","createFoldButton","entriesElements","len","onClickEntry","addToPointToElementsMap","lastElementChild","pointStartPositionRow","elms","itemStartPosition","editorPane","paneForItem","activate","getCursors","setBufferPosition","autoscroll","foldInitially","ProviderRegistry_2","providers","addProvider","provider","p","priority","splice","atom_1","removeProvider","getProviderForEditor","grammar","getGrammar","scopeName","findProvider","getAllProvidersForEditor","findAllProviders","grammarScopes","statAsync","util_1","fs_1","async","target","cwd","previousActiveItem","getActivePaneItem","getPath","dir","project","relativizePath","isDirectory","path_1","getPaths","wordAtPosition","position","wordRegex","wordRegex_","escaped","getNonWordCharacters","r","includeNonWordCharacters","wordAtPositionFromBuffer","getBuffer","getSingleWordAtPosition","match","wordMatch","buffer","rowRange","rangeForRow","matchData","scanInRange","data","range","start","isLessThanOrEqual","end","isGreaterThan","stop","rangeToTrim","stopRegex","backwardsScanInRange","component","assert_1","screenPositionForMouseEvent","selection","getSelectedText","getCursorScreenPosition","endPosition","regex","line","getTextInRange","exec","some","containsPoint","e","notifications","addError","name","stack","detail","lineCountIfLarge","threashold","largeFileMode","lineCount","getLineCount","lineLengthIfLong","i","lineLength","lineLengthForRow","largeLineCount","longLineLength","longLine","__exportStar","statuses","noEditor","noProvider","noResult","isObject_1","freeGlobal","freeSelf","self","root","now_1","now","reWhitespace","trimmedEndIndex","string","test","charAt","reTrimStart","_baseTrim","slice","_Symbol","Symbol","require$$0","objectProto","nativeObjectToString","symToStringTag","toStringTag","_getRawTag","isOwn","tag","unmasked","result","getRawTag","require$$1","objectToString","baseGetTag","isObjectLike","baseTrim","isObject","isSymbol","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","toNumber","other","valueOf","isBinary","nativeMax","nativeMin","min","debounce_1","func","wait","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","apply","leadingEdge","setTimeout","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","arguments","clearTimeout","cancel","flush","__classPrivateFieldGet","receiver","state","f","__classPrivateFieldSet","CallHierarchyView","providerRegistry","super","_CallHierarchyView_subscriptions","CompositeDisposable","_CallHierarchyView_editorSubscriptions","_CallHierarchyView_providerRegistry","_CallHierarchyView_outputElement","_CallHierarchyView_currentType","_CallHierarchyView_debounceWaitTime","_CallHierarchyView_status","_CallHierarchyView_toggleCurrentType","setAttribute","showCallHierarchy","_CallHierarchyView_updateCallHierarchyView","newData","prevStatus","currentStatus","getStatus","CallHierarchyViewItem","toggleAllItem","CallHierarchyViewStatusItem","headerElement","debouncedShowCallHierarchy","debounce","observeActiveTextEditor","newBufferPosition","destroyed","targetEditor","getActiveTextEditor","targetPoint","getCursorBufferPosition","getIncomingCallHierarchy","getOutgoingCallHierarchy","customElements","define","callHierarchy","_CallHierarchyViewItem_callHierarchy","_CallHierarchyViewItem_childCallHierarchies","_CallHierarchyViewItem_dblclickWaitTime","_CallHierarchyViewItem_showDocument","path","selectionRange","setCursorBufferPosition","scrollToBufferPosition","setSelectedBufferRange","open","initialLine","initialColumn","searchAllPanes","activatePane","activateItem","map","_item","itemAt","append","itemEl","escapeHTML","tags","str","querySelector","insertAdjacentElement","isDblclick","toggleItemAt","window","childCallHierarchy","isEmpty","querySelectorAll","titleEl","childEl","dataLen","Promise","all","TabHandler","createItem","_TabHandler_createItem","toggle","targetPane","show","delete","getRightDock","dock","getPaneContainers","find","v","getPanes","includes","addItem","destroyItem","pane","getActiveItem","getVisiblePanes","getActivePane","ProviderRegistry","subscriptions","callHierarchyTab","view","outlineProviderRegistry","onEditorChangedDisposable","editorChanged","getOutline","updateDebounceTime","largeness","editorLargeness","getDebounceTime","doubouncedGetOutline","getOutlintIfVisible","onDidDestroy","revealCursor","toggleOutlineView","outlinePane","rightDock","notifyError","outline","outlineTrees","Boolean","id","onDidChangeActiveTextEditor","catch","providerDisposer","prividerDisposable"],"mappings":"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"}