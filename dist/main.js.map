{"version":3,"file":"main.js","sources":["../node_modules/.pnpm/atom-ide-base@3.1.1/node_modules/atom-ide-base/src-commons-ui/scrollIntoView.ts","../node_modules/.pnpm/atom-ide-base@3.1.1/node_modules/atom-ide-base/src-commons-ui/items.ts","../node_modules/.pnpm/fast-equals@2.0.3/node_modules/fast-equals/src/utils.ts","../node_modules/.pnpm/fast-equals@2.0.3/node_modules/fast-equals/src/comparator.ts","../node_modules/.pnpm/fast-equals@2.0.3/node_modules/fast-equals/src/index.ts","../src/outlineView.ts","../src/utils.ts","../node_modules/.pnpm/atom-ide-base@3.1.1/node_modules/atom-ide-base/src-commons-atom/ProviderRegistry.ts","../node_modules/.pnpm/atom-ide-base@3.1.1/node_modules/atom-ide-base/src-commons-atom/getCwd.ts","../node_modules/.pnpm/atom-ide-base@3.1.1/node_modules/atom-ide-base/src-commons-atom/range.ts","../node_modules/.pnpm/atom-ide-base@3.1.1/node_modules/atom-ide-base/src-commons-atom/errors.ts","../node_modules/.pnpm/atom-ide-base@3.1.1/node_modules/atom-ide-base/src-commons-atom/editor-largeness.ts","../node_modules/.pnpm/atom-ide-base@3.1.1/node_modules/atom-ide-base/src-commons-atom/index.ts","../src/statuses.ts","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/now.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/debounce.js","../src/main.ts"],"sourcesContent":["/* globals getComputedStyle */\n\n/**\n * Use these functions instead of `Element::scrollIntoView()` and\n * `Element::scrollIntoViewIfNeeded()`!\n *\n * We've had a recurring issue in Nuclide (e.g. T20028138) where the UI would shift, leaving part of\n * the workspace element offscreen and a blank area in the window. This was caused by called to the\n * native `scrollIntoView()` and `scrollIntoViewIfNeeded()` which, according to the spec, has two\n * potentially surprising behaviors:\n *\n * 1. [It scrolls every scrollable ancestor (not just the closest)][1], where\n * 2. \"scrollable\" is [explicitly defined][2] to include elements with `overflow: hidden`\n *\n * This is surprising because `overflow: hidden` is typically used to make elements *not\n * scrollable*.\n *\n * Once the `overflow: hidden` element is scrolled, the user has no way to return it to its original\n * position (as it has no scrollbars).\n *\n * Note that this API doesn't support smooth scrolling. If that becomes necessary, we'll need to\n * come up with a better fix.\n *\n * It's tempting to assume that using `scrollIntoViewIfNeeded()` would fix this issue, however, if\n * the window is small enough so that no amount of scrolling the desired scrollable element would\n * ever reveal the element you're trying to, the browser will keep scrolling ancestors.\n *\n * [1]: https://drafts.csswg.org/cssom-view/#element-scrolling-members\n * [2]: https://drafts.csswg.org/cssom-view/#scrolling-box\n */\n\nexport function scrollIntoView(el: Element, alignToTop?: boolean): void {\n  const scrollTops = getScrollTops(el)\n  el.scrollIntoView(alignToTop)\n  restoreOverflowHiddenScrollTops(scrollTops)\n}\n\nexport type ElementExtended = Element & { scrollIntoViewIfNeeded?: (shouldCenter: boolean) => void }\n\nexport function scrollIntoViewIfNeeded(el: Element, center: boolean = true): void {\n  const scrollTops = getScrollTops(el)\n  // eslint-disable-next-line no-unused-expressions\n  ;(el as ElementExtended).scrollIntoViewIfNeeded?.(center) ?? el.scrollIntoView(center)\n  restoreOverflowHiddenScrollTops(scrollTops)\n}\n\nfunction getScrollTops(el_: Element): Map<Element, number> {\n  let el: Element | null = el_\n  const scrollTops = new Map<Element, number>()\n  while (el !== null) {\n    scrollTops.set(el, el.scrollTop)\n    el = el.parentElement\n  }\n  return scrollTops\n}\n\nfunction restoreOverflowHiddenScrollTops(scrollTops: Map<Element, number>): void {\n  scrollTops.forEach((scrollTop, el) => {\n    if (el.scrollTop !== scrollTop && isOverflowHidden(el)) {\n      el.scrollTop = scrollTop\n    }\n  })\n}\n\nexport function isOverflowHidden(el: HTMLElement | SVGElement | Element): boolean {\n  const overflowStyle = (el as HTMLElement)?.style.overflow\n  const overflow = overflowStyle ?? getComputedStyle(el).overflow\n  return overflow === \"hidden\"\n}\n","import type { Dock, ViewRegistry } from \"atom\"\n\n/** A function to detect if an item (view) is visible in Atom.\n * This is useful to skip code excecution or updating when the item is not visible.\n * @param item this is an item that is stored in {ViewRegistry}. It has the same type of the argument that you pass to `atom.view.getView(item)`.\n */\nexport function isItemVisible(item: Parameters<ViewRegistry[\"getView\"]>[0] | undefined | null) {\n  if (item === undefined || item === null) {\n    return false\n  }\n  // check the HTMLElement itself (important for when the dock/container is visible but the tab is not selected)\n  // try getting the element\n  const element = getItemElement(item)\n  if (element !== undefined && !isElementVisible(element)) {\n    return false\n    // if it we can't detect the invisiblity using HTML we need to consider Atom's context so we continue\n  }\n  // etch component\n  // if (item?.component?.visible === false) {\n  //   return false\n  // }\n  const paneContainer = atom.workspace.paneContainerForItem(item)\n  // if no container it is not visible\n  if (paneContainer === undefined) {\n    return false\n  } else if (typeof (paneContainer as any).isVisible === \"function\") {\n    // use Dock.isVisible()\n    return (paneContainer as Dock).isVisible()\n  } else {\n    // it is visible (when paneContainer is not a dock like TextEditor)\n    return true\n  }\n}\n\n/** A function to detect if an HTMLElement is visible. It doesn't consider the Atom context.\n * To detect if an item is visible in Atom use {isItemVisible} instead\n * This is useful to skip code excecution or updating when the element is not visible.\n * @param element\n */\nexport function isElementVisible(element: HTMLElement) {\n  if (\n    element instanceof HTMLElement &&\n    (element.style.display === \"none\" || element.hidden || element.offsetHeight === 0)\n  ) {\n    return false\n  }\n  return true\n}\n\n/**\n * Get the HTMLElement of an item using `.getElement()` or `.element`\n */\nexport function getItemElement(item: object | undefined | null) {\n  if (item === undefined || item === null) {\n    return undefined\n  }\n  return typeof (item as any).getElement === \"function\"\n    ? (item as { getElement: () => HTMLElement }).getElement()\n    : (item as { element: HTMLElement | undefined }).element\n}\n","const HAS_WEAKSET_SUPPORT = typeof WeakSet === 'function';\n\nconst { keys } = Object;\n\ntype Cache = {\n  add: (value: any) => void;\n  has: (value: any) => boolean;\n};\n\nexport type EqualityComparator = (a: any, b: any, meta?: any) => boolean;\n\n/**\n * are the values passed strictly equal or both NaN\n *\n * @param a the value to compare against\n * @param b the value to test\n * @returns are the values equal by the SameValueZero principle\n */\nexport function sameValueZeroEqual(a: any, b: any) {\n  return a === b || (a !== a && b !== b);\n}\n\n/**\n * is the value a plain object\n *\n * @param value the value to test\n * @returns is the value a plain object\n */\nexport function isPlainObject(value: any) {\n  return value.constructor === Object || value.constructor == null;\n}\n\n/**\n * is the value promise-like (meaning it is thenable)\n *\n * @param value the value to test\n * @returns is the value promise-like\n */\nexport function isPromiseLike(value: any) {\n  return !!value && typeof value.then === 'function';\n}\n\n/**\n * is the value passed a react element\n *\n * @param value the value to test\n * @returns is the value a react element\n */\nexport function isReactElement(value: any) {\n  return !!(value && value.$$typeof);\n}\n\n/**\n * in cases where WeakSet is not supported, creates a new custom\n * object that mimics the necessary API aspects for cache purposes\n *\n * @returns the new cache object\n */\nexport function getNewCacheFallback(): Cache {\n  const values: any[] = [];\n\n  return {\n    add(value: any) {\n      values.push(value);\n    },\n\n    has(value: any) {\n      return values.indexOf(value) !== -1;\n    },\n  };\n}\n\n/**\n * get a new cache object to prevent circular references\n *\n * @returns the new cache object\n */\nexport const getNewCache = ((canUseWeakMap: boolean) => {\n  if (canUseWeakMap) {\n    return function _getNewCache(): Cache {\n      return new WeakSet();\n    };\n  }\n\n  return getNewCacheFallback;\n})(HAS_WEAKSET_SUPPORT);\n\n/**\n * create a custom isEqual handler specific to circular objects\n *\n * @param [isEqual] the isEqual comparator to use instead of isDeepEqual\n * @returns the method to create the `isEqual` function\n */\nexport function createCircularEqualCreator(isEqual?: EqualityComparator) {\n  return function createCircularEqual(comparator: EqualityComparator) {\n    const _comparator = isEqual || comparator;\n\n    return function circularEqual(\n      a: any,\n      b: any,\n      cache: Cache = getNewCache(),\n    ) {\n      const isCacheableA = !!a && typeof a === 'object';\n      const isCacheableB = !!b && typeof b === 'object';\n\n      if (isCacheableA || isCacheableB) {\n        const hasA = isCacheableA && cache.has(a);\n        const hasB = isCacheableB && cache.has(b);\n\n        if (hasA || hasB) {\n          return hasA && hasB;\n        }\n\n        if (isCacheableA) {\n          cache.add(a);\n        }\n\n        if (isCacheableB) {\n          cache.add(b);\n        }\n      }\n\n      return _comparator(a, b, cache);\n    };\n  };\n}\n\n/**\n * are the arrays equal in value\n *\n * @param a the array to test\n * @param b the array to test against\n * @param isEqual the comparator to determine equality\n * @param meta the meta object to pass through\n * @returns are the arrays equal\n */\nexport function areArraysEqual(\n  a: any[],\n  b: any[],\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  let index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (!isEqual(a[index], b[index], meta)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * are the maps equal in value\n *\n * @param a the map to test\n * @param b the map to test against\n * @param isEqual the comparator to determine equality\n * @param meta the meta map to pass through\n * @returns are the maps equal\n */\nexport function areMapsEqual(\n  a: Map<any, any>,\n  b: Map<any, any>,\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  let isValueEqual = a.size === b.size;\n\n  if (isValueEqual && a.size) {\n    a.forEach((aValue, aKey) => {\n      if (isValueEqual) {\n        isValueEqual = false;\n\n        b.forEach((bValue, bKey) => {\n          if (!isValueEqual && isEqual(aKey, bKey, meta)) {\n            isValueEqual = isEqual(aValue, bValue, meta);\n          }\n        });\n      }\n    });\n  }\n\n  return isValueEqual;\n}\n\ntype Dictionary<Type> = {\n  [key: string]: Type;\n  [index: number]: Type;\n};\n\nconst OWNER = '_owner';\n\nconst hasOwnProperty = Function.prototype.bind.call(\n  Function.prototype.call,\n  Object.prototype.hasOwnProperty,\n);\n\n/**\n * are the objects equal in value\n *\n * @param a the object to test\n * @param b the object to test against\n * @param isEqual the comparator to determine equality\n * @param meta the meta object to pass through\n * @returns are the objects equal\n */\nexport function areObjectsEqual(\n  a: Dictionary<any>,\n  b: Dictionary<any>,\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  const keysA = keys(a);\n\n  let index = keysA.length;\n\n  if (keys(b).length !== index) {\n    return false;\n  }\n\n  if (index) {\n    let key: string;\n\n    while (index-- > 0) {\n      key = keysA[index];\n\n      if (key === OWNER) {\n        const reactElementA = isReactElement(a);\n        const reactElementB = isReactElement(b);\n\n        if (\n          (reactElementA || reactElementB) &&\n          reactElementA !== reactElementB\n        ) {\n          return false;\n        }\n      }\n\n      if (!hasOwnProperty(b, key) || !isEqual(a[key], b[key], meta)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * are the regExps equal in value\n *\n * @param a the regExp to test\n * @param b the regExp to test agains\n * @returns are the regExps equal\n */\nexport function areRegExpsEqual(a: RegExp, b: RegExp) {\n  return (\n    a.source === b.source &&\n    a.global === b.global &&\n    a.ignoreCase === b.ignoreCase &&\n    a.multiline === b.multiline &&\n    a.unicode === b.unicode &&\n    a.sticky === b.sticky &&\n    a.lastIndex === b.lastIndex\n  );\n}\n\n/**\n * are the sets equal in value\n *\n * @param a the set to test\n * @param b the set to test against\n * @param isEqual the comparator to determine equality\n * @param meta the meta set to pass through\n * @returns are the sets equal\n */\nexport function areSetsEqual(\n  a: Set<any>,\n  b: Set<any>,\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  let isValueEqual = a.size === b.size;\n\n  if (isValueEqual && a.size) {\n    a.forEach((aValue) => {\n      if (isValueEqual) {\n        isValueEqual = false;\n\n        b.forEach((bValue) => {\n          if (!isValueEqual) {\n            isValueEqual = isEqual(aValue, bValue, meta);\n          }\n        });\n      }\n    });\n  }\n\n  return isValueEqual;\n}\n","import {\n  EqualityComparator,\n  areArraysEqual,\n  areMapsEqual,\n  areObjectsEqual,\n  areRegExpsEqual,\n  areSetsEqual,\n  isPlainObject,\n  isPromiseLike,\n  sameValueZeroEqual,\n} from './utils';\n\nconst HAS_MAP_SUPPORT = typeof Map === 'function';\nconst HAS_SET_SUPPORT = typeof Set === 'function';\n\ntype EqualityComparatorCreator = (fn: EqualityComparator) => EqualityComparator;\n\nexport function createComparator(createIsEqual?: EqualityComparatorCreator) {\n  const isEqual: EqualityComparator =\n    /* eslint-disable no-use-before-define */\n    typeof createIsEqual === 'function'\n      ? createIsEqual(comparator)\n      : comparator;\n  /* eslint-enable */\n\n  /**\n   * compare the value of the two objects and return true if they are equivalent in values\n   *\n   * @param a the value to test against\n   * @param b the value to test\n   * @param [meta] an optional meta object that is passed through to all equality test calls\n   * @returns are a and b equivalent in value\n   */\n  function comparator(a: any, b: any, meta?: any) {\n    if (a === b) {\n      return true;\n    }\n\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\n      if (isPlainObject(a) && isPlainObject(b)) {\n        return areObjectsEqual(a, b, isEqual, meta);\n      }\n\n      let aShape = Array.isArray(a);\n      let bShape = Array.isArray(b);\n\n      if (aShape || bShape) {\n        return aShape === bShape && areArraysEqual(a, b, isEqual, meta);\n      }\n\n      aShape = a instanceof Date;\n      bShape = b instanceof Date;\n\n      if (aShape || bShape) {\n        return (\n          aShape === bShape && sameValueZeroEqual(a.getTime(), b.getTime())\n        );\n      }\n\n      aShape = a instanceof RegExp;\n      bShape = b instanceof RegExp;\n\n      if (aShape || bShape) {\n        return aShape === bShape && areRegExpsEqual(a, b);\n      }\n\n      if (isPromiseLike(a) || isPromiseLike(b)) {\n        return a === b;\n      }\n\n      if (HAS_MAP_SUPPORT) {\n        aShape = a instanceof Map;\n        bShape = b instanceof Map;\n\n        if (aShape || bShape) {\n          return aShape === bShape && areMapsEqual(a, b, isEqual, meta);\n        }\n      }\n\n      if (HAS_SET_SUPPORT) {\n        aShape = a instanceof Set;\n        bShape = b instanceof Set;\n\n        if (aShape || bShape) {\n          return aShape === bShape && areSetsEqual(a, b, isEqual, meta);\n        }\n      }\n\n      return areObjectsEqual(a, b, isEqual, meta);\n    }\n\n    return a !== a && b !== b;\n  }\n\n  return comparator;\n}\n","import { createComparator } from './comparator';\nimport { createCircularEqualCreator, sameValueZeroEqual } from './utils';\n\nexport { createComparator as createCustomEqual, sameValueZeroEqual };\n\nexport const deepEqual = createComparator();\nexport const shallowEqual = createComparator(() => sameValueZeroEqual);\n\nexport const circularDeepEqual = createComparator(createCircularEqualCreator());\nexport const circularShallowEqual = createComparator(\n  createCircularEqualCreator(sameValueZeroEqual),\n);\n","import { TextEditor, Point, Disposable } from \"atom\"\nimport type { OutlineTree } from \"atom-ide-base\"\nimport { scrollIntoViewIfNeeded } from \"atom-ide-base/commons-ui/scrollIntoView\"\nimport { isItemVisible } from \"atom-ide-base/commons-ui/items\"\nimport { TreeFilterer, Tree } from \"zadeh\"\nimport { unique } from \"./utils\"\nimport { setStatus } from \"./main\"\n\nexport class OutlineView {\n  public element: HTMLDivElement\n\n  /** Contains the content of the outline which is either the status element or the list element */\n  public outlineContent: HTMLDivElement\n  /** The actual outline list element */\n  private outlineList: HTMLUListElement | undefined = undefined\n\n  /** Cache for reveal corsur */\n  private pointToElementsMap = new Map<number, Array<HTMLLIElement>>() // TODO Point to element\n  /** Cache for focused elements */\n  private focusedElms: HTMLElement[] | undefined\n  /** Cache of last rendered list used to avoid rerendering */\n  lastEntries: OutlineTree[] | undefined\n\n  private treeFilterer = new TreeFilterer<\"representativeName\" | \"plainText\", \"children\">()\n  public searchBarEditor: TextEditor | undefined\n  private searchBarEditorDisposable: Disposable | undefined\n  private selectCursorDisposable: Disposable | undefined\n\n  constructor() {\n    this.element = document.createElement(\"div\")\n    this.element.classList.add(\"atom-ide-outline\")\n\n    this.element.appendChild(makeOutlineToolbar())\n    this.element.appendChild(this.createSearchBar())\n\n    this.outlineContent = document.createElement(\"div\")\n    this.element.appendChild(this.outlineContent)\n\n    this.outlineContent.classList.add(\"outline-content\")\n  }\n\n  reset() {\n    this.searchBarEditorDisposable?.dispose()\n    this.selectCursorDisposable?.dispose()\n    this.searchBarEditor?.setText(\"\")\n  }\n\n  destroy() {\n    this.element.remove()\n  }\n\n  getElement() {\n    return this.element\n  }\n\n  // needed for Atom\n  /* eslint-disable class-methods-use-this */\n  getTitle() {\n    return \"Outline\"\n  }\n\n  getIconName() {\n    return \"list-unordered\"\n  }\n  /* eslint-enable class-methods-use-this */\n\n  /**\n   * The main function of {OutlineView} which renders the content in the outline or only update the event listeners if\n   * the outline tree hasn't changed\n   */\n  setOutline(outlineTree: OutlineTree[], editor: TextEditor, isLarge: boolean) {\n    // skip rendering if it is the same\n    // TIME 0.2-1.2ms // the check itself takes ~0.2-0.5ms, so it is better than rerendering\n    if (this.lastEntries !== undefined && hasEqualContent(outlineTree, this.lastEntries)) {\n      this.pointToElementsMap.clear() // empty revealCorsur cache\n      addEntriesOnClick(\n        this.outlineList! /* because this.lastEntries is not undefined */,\n        outlineTree,\n        editor,\n        this.pointToElementsMap,\n        0\n      )\n      return\n    } else {\n      this.lastEntries = outlineTree\n    }\n\n    this.createOutlineList(outlineTree, editor, isLarge)\n  }\n\n  /** The function to render the content in the outline */\n  createOutlineList(outlineTree: OutlineTree[], editor: TextEditor, isLarge: boolean) {\n    this.clearContent()\n\n    if (isLarge) {\n      this.outlineContent.appendChild(createLargeFileElement())\n    }\n    this.updateSearchBar(outlineTree, editor, isLarge)\n\n    this.outlineList = createOutlineList(outlineTree, editor, isLarge, this.pointToElementsMap)\n    this.outlineContent.appendChild(this.outlineList)\n  }\n\n  clearContent() {\n    this.outlineContent.innerHTML = \"\"\n    if (this.outlineList !== undefined) {\n      this.outlineList.dataset.editorRootScope = \"\"\n    }\n    this.lastEntries = undefined\n  }\n\n  updateSearchBar(outlineTree: OutlineTree[], editor: TextEditor, isLarge: boolean) {\n    this.searchBarEditorDisposable?.dispose()\n\n    // detect if representativeName exists on an entry of the tree, if it doesn't, then we use plainText\n    const firstOutlineTree = outlineTree[0]\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const dataKey = firstOutlineTree?.representativeName !== undefined ? \"representativeName\" : \"plainText\"\n\n    // @ts-ignore we check if representitiveName is undefined, and if it is, we will use plainText instead\n    this.treeFilterer.setCandidates(outlineTree, dataKey, \"children\")\n\n    this.searchBarEditorDisposable = this.searchBarEditor?.onDidStopChanging(() =>\n      this.filterOutlineTree(editor, isLarge)\n    )\n  }\n\n  createSearchBar() {\n    this.searchBarEditor = new TextEditor({ mini: true, placeholderText: \"Filter\" })\n\n    const searchBar = document.createElement(\"div\")\n    searchBar.classList.add(\"outline-searchbar\")\n\n    searchBar.appendChild(atom.views.getView(this.searchBarEditor))\n\n    return searchBar\n  }\n\n  renderLastOutlienList() {\n    if (this.outlineList !== undefined) {\n      this.clearContent()\n      this.outlineContent.appendChild(this.outlineList)\n    }\n  }\n\n  filterOutlineTree(editor: TextEditor, isLarge: boolean) {\n    // @ts-ignore\n    if (!(editor.isAlive() as boolean) || !isItemVisible(editor)) {\n      return\n    }\n\n    const text = this.searchBarEditor?.getText()\n    if (typeof text !== \"string\") {\n      this.renderLastOutlienList()\n      return\n    }\n    const query = text.trim()\n    if (query.length === 0) {\n      this.renderLastOutlienList()\n      return\n    }\n    let filterResults: Tree<\"representativeName\" | \"plainText\", \"children\">[]\n    try {\n      filterResults = this.treeFilterer.filter(query, { maxResults: 100, usePathScoring: false })\n    } catch (err) {\n      const error = err as Error\n      error.message = `Filtering failed for unkown reasons.\\n${error.message}`\n      console.error(error)\n      this.reset()\n      // Retry:\n      // @ts-ignore internal api\n      const candidates = this.treeFilterer.candidates as Tree<\"representativeName\" | \"plainText\", \"children\">[]\n      this.treeFilterer = new TreeFilterer(candidates)\n      this.updateSearchBar(candidates as unknown as OutlineTree[], editor, isLarge)\n      this.searchBarEditor?.setText(query)\n      this.filterOutlineTree(editor, isLarge)\n      return\n    }\n\n    // TODO why returns duplicates? ~0-0.2s\n    const filteredTree = unique(filterResults)\n    if (filteredTree.length === 0) {\n      return setStatus(\"noResult\")\n    }\n    const filteredOutlineList = createOutlineList(\n      filteredTree as unknown as OutlineTree[],\n      editor,\n      isLarge,\n      this.pointToElementsMap\n    )\n    this.clearContent()\n    this.outlineContent.appendChild(filteredOutlineList)\n  }\n\n  presentStatus(status: { title: string; description: string }) {\n    this.clearContent()\n\n    const statusElement = generateStatusElement(status)\n\n    this.outlineContent.appendChild(statusElement)\n  }\n\n  // callback for scrolling and highlighting the element that the cursor is on\n  selectAtCursorLine(editor: TextEditor) {\n    const cursor = editor.getLastCursor()\n\n    // skip if not visible\n    if (!isItemVisible(this)) {\n      return\n    }\n\n    if (clicked) {\n      // HACK do not scroll when the cursor has moved to a click on the outline entry\n      clicked = false\n      return\n    }\n\n    // TIME: ~0.2-0.3ms\n    // TODO use range of start and end instead of just the line number\n\n    // remove old cursorOn attribue\n    if (this.focusedElms !== undefined) {\n      for (const elm of this.focusedElms) {\n        elm.toggleAttribute(\"cursorOn\", false)\n      }\n    }\n\n    // add new cursorOn attribue\n    const cursorPoint = cursor.getBufferRow()\n    this.focusedElms = this.pointToElementsMap.get(cursorPoint)\n\n    // search in between the points\n    if (this.focusedElms === undefined) {\n      const points = this.pointToElementsMap.keys()\n      let previousPoint: number = 0\n      for (const point of points) {\n        // find the first point which has a larger point\n        if (point >= cursorPoint) {\n          const previousElms = this.pointToElementsMap.get(previousPoint)!\n          previousElms[previousElms.length - 1].classList.add(\"after-border\")\n          const currentElms = this.pointToElementsMap.get(point)!\n          this.focusedElms = [...currentElms, ...previousElms] // in reverse so the previous elms are scrolled into in the end\n          break\n        } else {\n          // update previous point for the next iteration\n          previousPoint = point\n        }\n      }\n    }\n\n    // add cursorOn and scrollInto\n    if (this.focusedElms !== undefined) {\n      for (const elm of this.focusedElms) {\n        scrollIntoViewIfNeeded(elm, true)\n        elm.toggleAttribute(\"cursorOn\", true)\n      }\n      // remove focus once cursor moved\n      this.selectCursorDisposable = editor.onDidChangeCursorPosition(() => {\n        if (this.focusedElms !== undefined) {\n          for (const elm of this.focusedElms) {\n            elm.toggleAttribute(\"cursorOn\", false)\n          }\n        }\n        this.selectCursorDisposable?.dispose()\n      })\n    }\n    // focus on the editor after finding\n    atom.views.getView(editor).focus()\n  }\n}\n\n/** Create the main outline list */\nfunction createOutlineList(\n  outlineTree: OutlineTree[],\n  editor: TextEditor,\n  isLarge: boolean,\n  pointToElementsMap: Map<number, Array<HTMLLIElement>>\n) {\n  const outlineList = document.createElement(\"ul\")\n  outlineList.dataset.editorRootScope = editor.getRootScopeDescriptor().getScopesArray().join(\" \")\n\n  const tabLength = editor.getTabLength()\n  if (typeof tabLength === \"number\") {\n    outlineList.style.setProperty(\"--editor-tab-length\", Math.max(tabLength / 2, 2).toString(10))\n  }\n  addOutlineEntries(\n    outlineList,\n    outlineTree,\n    editor,\n    /* foldInItially */ isLarge || (atom.config.get(\"atom-ide-outline.foldInitially\") as boolean),\n    0\n  )\n  // TIME 0.2-0.5m\n  addEntriesOnClick(outlineList, outlineTree, editor, pointToElementsMap, 0)\n  return outlineList\n}\n\n/** Compares the content of the two given {OutlineTree[]} It only compares the content that affects rendering */\nfunction hasEqualContent(ot1: OutlineTree[], ot2: OutlineTree[]) {\n  // simple compare\n  if (ot1 === ot2) {\n    return true\n  } else {\n    // compare length\n    const ot1Len = ot1.length\n    const ot2Len = ot2.length\n    if (ot1Len !== ot2Len) {\n      return false\n    }\n    // compare the content\n    for (let iEntry = 0; iEntry < ot1Len; iEntry++) {\n      const e1 = ot1[iEntry]\n      const e2 = ot2[iEntry]\n      if (\n        e1.representativeName !== e2.representativeName ||\n        e1.plainText !== e2.plainText ||\n        e1.kind !== e2.kind ||\n        e1.icon !== e2.icon ||\n        !hasEqualContent(e1.children, e2.children)\n      ) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\nfunction makeOutlineToolbar() {\n  const toolbar = document.createElement(\"span\")\n  toolbar.className = \"outline-toolbar\"\n\n  const revealCursorButton = document.createElement(\"button\")\n  revealCursorButton.innerHTML = \"Reveal Cursor\"\n  revealCursorButton.className = \"btn outline-btn\"\n\n  revealCursorButton.addEventListener(\"click\", () =>\n    atom.commands.dispatch(atom.views.getView(atom.workspace), \"outline:reveal-cursor\")\n  )\n\n  toolbar.appendChild(revealCursorButton)\n  return toolbar\n}\n\nfunction createLargeFileElement() {\n  const largeFileElement = document.createElement(\"div\")\n  largeFileElement.innerHTML = `<span class=\"large-file-mode\">Large file mode</span>`\n  return largeFileElement\n}\n\nfunction generateStatusElement(status: { title: string; description: string }) {\n  const element = document.createElement(\"div\")\n  element.className = \"status\"\n\n  const { title = \"\", description = \"\" } = status\n  element.innerHTML = `<h1>${title}</h1>\n  <span>${description}</span>`\n\n  return element\n}\n\nfunction hasChildren(entry: OutlineTree) {\n  return entry.children.length >= 1\n}\n\nfunction sortEntries(entries: OutlineTree[]) {\n  if (atom.config.get(\"atom-ide-outline.sortEntries\") as boolean) {\n    entries.sort((e1: OutlineTree, e2: OutlineTree) => {\n      const rowCompare = e1.startPosition.row - e2.startPosition.row\n      if (rowCompare === 0) {\n        // compare based on column if on the same row\n        return e1.startPosition.column - e1.startPosition.column\n      }\n      return rowCompare\n    })\n  }\n}\n\nfunction addOutlineEntries(\n  parent: HTMLUListElement,\n  entries: OutlineTree[],\n  editor: TextEditor,\n  isLarge: boolean,\n  level: number\n) {\n  // NOTE: this function is called multiple times with each update in an editor!\n  // a few of the calls is slow ~1-100ms\n\n  // TIME 0.1ms\n  sortEntries(entries)\n\n  for (const item of entries) {\n    const symbol = document.createElement(\"li\")\n\n    // symbol.setAttribute(\"level\", `${level}`); // store level in the element\n\n    // Hold an entry in a dedicated element to prevent hover conflicts - hover over an <li> tag would be cought by a parent <li>\n    // TIME: ~0-0.1ms\n    const labelElement = document.createElement(\"span\")\n\n    // TODO support item.tokenizedText\n    labelElement.innerText = item.representativeName ?? item.plainText ?? \"\"\n\n    labelElement.prepend(/* iconElement */ getIcon(item.icon, item.kind))\n\n    symbol.appendChild(labelElement)\n\n    if (hasChildren(item)) {\n      // create Child elements\n      // TIME 0-0.2ms\n      const childrenList = document.createElement(\"ul\")\n      childrenList.style.setProperty(\"--indent-level\", (level + 1).toString(10))\n      childrenList.addEventListener(\"click\", (event) => event.stopPropagation(), { passive: true })\n      symbol.appendChild(childrenList)\n\n      // fold Button\n      const foldButton = createFoldButton(childrenList, isLarge)\n      labelElement.prepend(foldButton)\n\n      // add children to outline\n      // TIME: last one of each batch is slower 0-20ms\n      addOutlineEntries(childrenList, item.children, editor, isLarge, level + 1)\n    }\n\n    // TIME: <0.1ms\n    parent.appendChild(symbol)\n  }\n}\n\n/**\n * Adds onClick to the outline entries.\n *\n * @attention The assumption about the type of Elements are added using `as HTML...`. After editing code, make sure that the types are correct\n */\nfunction addEntriesOnClick(\n  parent: HTMLUListElement,\n  entries: OutlineTree[],\n  editor: TextEditor,\n  pointToElementsMap: Map<number, Array<HTMLLIElement>>,\n  level: number\n) {\n  const entriesElements = parent.children\n  for (let iEntry = 0, len = entries.length; iEntry < len; iEntry++) {\n    const item = entries[iEntry]\n    const element = entriesElements[iEntry] as HTMLLIElement\n\n    // Cursor reposition on click\n    element.addEventListener(\"click\", () => onClickEntry(item.startPosition, editor), { passive: true })\n\n    // update the cache for selectAtCursorLine\n    addToPointToElementsMap(pointToElementsMap, item.startPosition.row, element)\n\n    if (hasChildren(item)) {\n      const chilrenRootElement = element.lastElementChild as HTMLUListElement\n      addEntriesOnClick(chilrenRootElement, item.children, editor, pointToElementsMap, level + 1)\n    }\n  }\n}\n\n/** Update start position => elements map used in `selectAtCursorLine` */\nfunction addToPointToElementsMap(\n  pointToElementsMap: Map<number, Array<HTMLLIElement>>,\n  pointStartPositionRow: number,\n  element: HTMLLIElement\n) {\n  // TIME: 0-0.2ms\n  const elms = pointToElementsMap.get(pointStartPositionRow)\n  if (elms !== undefined) {\n    elms.push(element)\n    pointToElementsMap.set(pointStartPositionRow, elms)\n  } else {\n    pointToElementsMap.set(pointStartPositionRow, [element])\n  }\n}\n\nlet clicked: boolean = false // HACK used to prevent scrolling in the outline list when an entry is clicked\n\nfunction onClickEntry(itemStartPosition: Point, editor: TextEditor) {\n  // only uses a reference to the editor and the pane and corsur are calculated on the fly\n  const editorPane = atom.workspace.paneForItem(editor)\n  if (editorPane === undefined) {\n    return\n  }\n  editorPane.activate()\n\n  editor.getCursors()[0].setBufferPosition(itemStartPosition, {\n    autoscroll: true,\n  })\n  // HACK\n  clicked = true\n}\n\nfunction getIcon(iconType: string | undefined, kindTypeGiven: string | undefined) {\n  let kindType = kindTypeGiven\n  // LSP specification: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_documentSymbol\n  // atom-languageclient mapping: https://github.com/atom/atom-languageclient/blob/485bb9d706b422456640c9070eee456ef2cf09c0/lib/adapters/outline-view-adapter.ts#L270\n\n  const iconElement = document.createElement(\"span\")\n  iconElement.classList.add(\"outline-icon\")\n\n  // if iconType given instead\n  if (kindType === undefined && iconType !== undefined) {\n    kindType = iconType\n  }\n\n  let type: string = \"🞇\"\n  if (typeof kindType === \"string\" && kindType.length > 0) {\n    let kindClass: string\n    // hasKind\n    if (kindType.indexOf(\"type-\") === 0) {\n      // supplied with type-...\n      kindClass = `${kindType}`\n      type = kindType.replace(\"type-\", \"\")\n    } else {\n      // supplied without type-\n      kindClass = `type-${kindType}`\n      type = kindType\n    }\n    iconElement.classList.add(kindClass)\n  }\n\n  iconElement.innerHTML = `<span>${type.substring(0, 3)}</span>`\n\n  return iconElement\n}\n\nfunction createFoldButton(childrenList: HTMLUListElement, foldInitially: boolean) {\n  // TIME: ~0.1-0.5ms\n  // fold button\n  const foldButton = document.createElement(\"button\")\n\n  if (foldInitially) {\n    // collapse in large files by default\n    childrenList.hidden = true\n    foldButton.classList.add(\"outline-fold-btn\", \"collapsed\")\n  } else {\n    foldButton.classList.add(\"outline-fold-btn\", \"expanded\")\n  }\n\n  // fold listener\n  foldButton.addEventListener(\n    \"click\",\n    (event) => {\n      childrenList.hidden = !childrenList.hidden\n      if (childrenList.hidden) {\n        foldButton.classList.remove(\"expanded\")\n        foldButton.classList.add(\"collapsed\")\n      } else {\n        foldButton.classList.remove(\"collapsed\")\n        foldButton.classList.add(\"expanded\")\n      }\n      event.stopPropagation()\n    },\n    { passive: true }\n  )\n  return foldButton\n}\n","import { deepEqual } from \"fast-equals\"\n\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nexport function unique<T extends Record<string, any>>(array: T[]) {\n  return array.filter((elm2, index) => array.findIndex((elm1) => deepEqual(elm1, elm2)) === index)\n}\n","import { Disposable, TextEditor } from \"atom\"\nimport { Provider as ProviderTypes, BusySignalProvider, FindReferencesProvider } from \"../types-packages/main.d\"\n\nexport class ProviderRegistry<Provider extends Exclude<ProviderTypes, BusySignalProvider | FindReferencesProvider>> {\n  private providers: Array<Provider>\n\n  constructor() {\n    this.providers = []\n  }\n\n  addProvider(provider: Provider): Disposable {\n    const index = this.providers.findIndex((p) => provider.priority > p.priority)\n    if (index === -1) {\n      this.providers.push(provider)\n    } else {\n      this.providers.splice(index, 0, provider)\n    }\n    return new Disposable(() => {\n      this.removeProvider(provider)\n    })\n  }\n\n  removeProvider(provider: Provider): void {\n    const index = this.providers.indexOf(provider)\n    if (index !== -1) {\n      this.providers.splice(index, 1)\n    }\n  }\n\n  // TODO deprecate since there can be N providers.\n  getProviderForEditor(editor: TextEditor): Provider | null {\n    const grammar = editor.getGrammar().scopeName\n    return this.findProvider(grammar)\n  }\n\n  // TODO create an ordering or priority aware util to prefer instead.\n  getAllProvidersForEditor(editor: TextEditor): Iterable<Provider> {\n    const grammar = editor.getGrammar().scopeName\n    return this.findAllProviders(grammar)\n  }\n\n  findProvider(grammar: string): Provider | null {\n    for (const provider of this.findAllProviders(grammar)) {\n      return provider\n    }\n    return null\n  }\n\n  /**\n   * Iterates over all providers matching the grammar, in priority order.\n   */\n  *findAllProviders(grammar: string): Iterable<Provider> {\n    for (const provider of this.providers) {\n      if (provider.grammarScopes == null || provider.grammarScopes.indexOf(grammar) !== -1) {\n        yield provider\n      }\n    }\n  }\n}\n","import { dirname } from \"path\"\nimport { promisify } from \"util\"\nimport { stat } from \"fs\"\nconst statAsync = promisify(stat)\n\nexport async function getCwd(target = \"\"): Promise<string | undefined> {\n  let cwd: string\n\n  if (target) {\n    cwd = target\n  } else {\n    const previousActiveItem = atom.workspace.getActivePaneItem() as { getPath?: () => string }\n    cwd = previousActiveItem?.getPath?.() as string\n    if (cwd) {\n      const dir = atom.project.relativizePath(cwd)[0]\n      if (dir) {\n        // Use project paths whenever they are available by default.\n        return dir\n      }\n    }\n  }\n\n  try {\n    if (cwd) {\n      // Otherwise, if the path exists on the local file system, use the\n      // path or parent directory as appropriate.\n      const stats = await statAsync(cwd)\n      if (stats.isDirectory()) {\n        return cwd\n      }\n\n      cwd = dirname(cwd)\n      const dirStats = await statAsync(cwd)\n      if (dirStats.isDirectory()) {\n        return cwd\n      }\n    }\n  } catch {\n    //fail silently\n  }\n\n  cwd = atom.project.getPaths()[0]\n  // no project paths\n  return cwd\n}\n","import { TextEditor, TextEditorComponent, TextBuffer, Range, Point } from \"atom\"\nimport invariant from \"assert\"\n\n/**\n * Finds the word at the position. You can either provide a word regex yourself,\n * or have Atom use the word regex in force at the scopes at that position,\n * in which case it uses the optional includeNonWordCharacters, default true.\n * (I know that's a weird default but it follows Atom's convention...)\n */\nexport function wordAtPosition(\n  editor: TextEditor,\n  position: Point,\n  wordRegex?: RegExp | { includeNonWordCharacters: boolean }\n): { wordMatch: Array<string>; range: Range } | null {\n  let wordRegex_\n  if (wordRegex instanceof RegExp) {\n    wordRegex_ = wordRegex\n  } else {\n    // What is the word regex associated with the position? We'd like to use\n    // Cursor.wordRegExp, except that function gets the regex associated\n    // with the editor's current cursor while we want the regex associated with\n    // the specific position. So we re-implement it ourselves...\n    // @ts-ignore: https://github.com/atom/atom/blob/aa3c34bedb361e09a5068dce9620b460a20ca3fb/src/text-editor.js#L5032\n    const nonWordChars: string = editor.getNonWordCharacters(position)\n    const escaped = nonWordChars.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n    // We copied this escaping regex from Cursor.wordRegexp, rather than\n    // using the library function 'escapeStringRegExp'. That's because the\n    // library function doesn't escape the hyphen character and so is\n    // unsuitable for use inside a range.\n    let r = `^[\\t ]*$|[^\\\\s${escaped}]+`\n    if (wordRegex == null || wordRegex.includeNonWordCharacters) {\n      r += `|[${escaped}]+`\n    }\n    wordRegex_ = new RegExp(r, \"g\")\n  }\n  return wordAtPositionFromBuffer(editor.getBuffer(), position, wordRegex_)\n}\n\n/**\n * Gets the trimmed range from a given range, i.e. moves the start and end points\n * to the first and last non-whitespace characters (or specified regex)\n * within the range respectively.\n *\n * @param editor       the editor containing the range\n * @param rangeToTrim  the range to trim\n * @param stopRegex    stop trimming when the first match is found for this regex,\n *   defaults to first non-whitespace character\n * @return Range  the trimmed range\n */\nexport function trimRange(editor: TextEditor, rangeToTrim: Range, stopRegex: RegExp = /\\S/): Range {\n  const buffer = editor.getBuffer()\n  let { start, end } = rangeToTrim\n  buffer.scanInRange(stopRegex, rangeToTrim, ({ range, stop }) => {\n    start = range.start\n    stop()\n  })\n  buffer.backwardsScanInRange(stopRegex, rangeToTrim, ({ range, stop }) => {\n    end = range.end\n    stop()\n  })\n  return new Range(start, end)\n}\n\nfunction getSingleWordAtPosition(editor: TextEditor, position: Point): string | null {\n  const match = wordAtPosition(editor, position)\n  // We should only receive a single identifier from a single point.\n  if (match == null || match.wordMatch.length !== 1) {\n    return null\n  }\n\n  return match.wordMatch[0]\n}\n\n/**\n * Gets the word being right-clicked on in a MouseEvent. A good use case for\n * this is performing an action on a word from a context menu.\n *\n * @param editor  the editor containing the word where the MouseEvent occurred\n *   from\n * @param event   the MouseEvent containing the screen position of the click\n */\nexport function getWordFromMouseEvent(editor: TextEditor, event: MouseEvent): string | null {\n  // We can't immediately get the identifier right-clicked on from\n  // the MouseEvent. Using its target element content would work in\n  // some cases but wouldn't work if there was additional content\n  // in the same element, such as in a comment.\n  // @ts-ignore: https://github.com/atom/atom/blob/aa3c34bedb361e09a5068dce9620b460a20ca3fb/src/text-editor.js#L5075\n  const component: TextEditorComponent = editor.getElement().component\n  invariant(component)\n  // This solution doesn't feel ideal but it is the way hyperclick does it.\n  const point = component.screenPositionForMouseEvent(event)\n  return getSingleWordAtPosition(editor, point)\n}\n\n/**\n * Attempts to get a word from the last selection or cursor. A good use case for\n * this is performing an action on an 'active' word after a command is triggered\n * via a keybinding.\n *\n * @param editor  the editor containing the 'active' word when the keybinding is\n *   triggered\n */\nexport function getWordFromCursorOrSelection(editor: TextEditor): string | null {\n  const selection = editor.getSelectedText()\n  if (selection && selection.length > 0) {\n    return selection\n  }\n\n  // There was no selection so we can go ahead and try the cursor position.\n  const point = editor.getCursorScreenPosition()\n  return getSingleWordAtPosition(editor, point)\n}\n\nexport function wordAtPositionFromBuffer(\n  buffer: TextBuffer,\n  position: Point,\n  wordRegex: RegExp\n): { wordMatch: Array<string>; range: Range } | null {\n  const { row, column } = position\n  const rowRange = buffer.rangeForRow(row)\n  let matchData: { match: Array<string>; range: Range } | null\n  // Extract the expression from the row text.\n  buffer.scanInRange(wordRegex, rowRange, (data) => {\n    const { range } = data\n    if (range.start.isLessThanOrEqual(position) && range.end.isGreaterThan(position)) {\n      matchData = data\n    }\n    // Stop the scan if the scanner has passed our position.\n    if (range.end.column > column) {\n      data.stop()\n    }\n  })\n  // @ts-ignore (it is assigned above)\n  if (matchData) {\n    return {\n      wordMatch: matchData.match,\n      range: matchData.range,\n    }\n  } else {\n    return null\n  }\n}\n\n// Matches a regex on the text of the line ending at endPosition.\n// regex should end with a '$'.\n// Useful for autocomplete.\nexport function matchRegexEndingAt(buffer: TextBuffer, endPosition: Point, regex: RegExp): string | null {\n  const line = buffer.getTextInRange([[endPosition.row, 0], endPosition])\n  const match = regex.exec(line)\n  return match == null ? null : match[0]\n}\n\nexport function isPositionInRange(position: Point, range: Range | Array<Range>): boolean {\n  return Array.isArray(range) ? range.some((r) => r.containsPoint(position)) : range.containsPoint(position)\n}\n","/** Show a JavaScript Error as an atom notifications */\nexport function notifyError(e: Error) {\n  atom.notifications.addError(e.name, {\n    stack: e.stack,\n    detail: e.message,\n  })\n}\n","import { TextEditor } from \"atom\"\n\n/**\n * Find if an editor's largeness based on the given threashold\n * @param editor\n * @param largeLineCount lineCountIfLarge threashold\n * @param longLineLength lineLengthIfLong threashold\n * @returns the largness score if editor is large. Otherwise it returns 0 (a small file)\n */\nexport function largeness(\n  editor: TextEditor,\n  largeLineCount: number = atom.config.get(\"atom-ide-base.largeLineCount\") || 4000,\n  longLineLength: number = atom.config.get(\"atom-ide-base.longLineLength\") || 4000\n) {\n  const lineCount = lineCountIfLarge(editor, largeLineCount)\n  if (lineCount !== 0) {\n    return lineCount\n  }\n  const longLine = lineLengthIfLong(editor, longLineLength)\n  if (longLine !== 0) {\n    return longLine\n  }\n  return 0 // small file\n}\n\n/**\n * Find if an editor has a line that is longer than the given threashold\n * @param editor\n * @param threashold largeLineCount threashold\n * @returns the line count if it is larger than threashold. Otherwise it returns 0 (a small file)\n */\nexport function lineCountIfLarge(editor: TextEditor, threashold: number) {\n  // @ts-ignore\n  if (editor.largeFileMode) {\n    return 100000\n  }\n  const lineCount = editor.getLineCount()\n  if (lineCount >= threashold) {\n    return lineCount\n  }\n  return 0 // small file\n}\n\n/**\n * Find if an editor has a line that is longer than the given threashold\n * @param editor\n * @param threashold lineLengthForRow threashold\n * @param lineCount count up to this line. Default is {editor.getLineCount()}\n * @returns the first line length that has a length larger than threashold. If no line is found, it returns 0\n */\nexport function lineLengthIfLong(editor: TextEditor, threashold: number, lineCount: number = editor.getLineCount()) {\n  const buffer = editor.getBuffer()\n  for (let i = 0, len = lineCount; i < len; i++) {\n    const lineLength = buffer.lineLengthForRow(i)\n    if (lineLength > threashold) {\n      return lineLength\n    }\n  }\n  return 0 // small file\n}\n","export * from \"./getCwd\"\nexport * from \"./ProviderRegistry\"\nexport * from \"./range\"\nexport * from \"./errors\"\nexport * from \"./editor-largeness\"\n","export const statuses = {\n  noEditor: {\n    title: \"Outline is unavailable.\",\n    description: \"Open a text editor.\",\n  },\n  noProvider: {\n    title: \"Provider is unavailable\",\n    description:\n      \"Looks like a provider for this type of file is not available. Check if a relevant IDE language package is installed and has outline support, or try adding one from Atom's package registry (e.g.: atom-ide-javascript, atom-typescript, ide-python, ide-rust, ide-css, ide-json).\",\n  },\n  noResult: {\n    title: \"No result was found.\",\n    description: \"The Outline could not found the text you entered in the filter bar.\",\n  },\n}\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n","var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","import { CompositeDisposable, TextEditor } from \"atom\"\nimport { OutlineView } from \"./outlineView\"\nimport type { OutlineProvider } from \"atom-ide-base\"\nimport { ProviderRegistry } from \"atom-ide-base/commons-atom/ProviderRegistry\"\nimport { notifyError, largeness as editorLargeness } from \"atom-ide-base/commons-atom\"\nimport { isItemVisible } from \"atom-ide-base/commons-ui/items\"\n\nexport { statuses } from \"./statuses\" // for spec\nimport { statuses } from \"./statuses\"\nimport debounce from \"lodash/debounce\"\n\nconst subscriptions = new CompositeDisposable()\n\nlet view: OutlineView | undefined\nexport const outlineProviderRegistry = new ProviderRegistry<OutlineProvider>()\n\n// let busySignalProvider: BusySignalProvider | undefined // service might be consumed late\n\nexport function activate() {\n  addCommands()\n  addObservers()\n  if (atom.config.get(\"atom-ide-outline.initialDisplay\") as boolean) {\n    // initially show outline pane\n    toggleOutlineView().catch((e: Error) => {\n      notifyError(e)\n    })\n  }\n}\n\nfunction addCommands() {\n  subscriptions.add(\n    /* outlineToggle */ atom.commands.add(\"atom-workspace\", \"outline:toggle\", toggleOutlineView),\n    /* revealCursor */ atom.commands.add(\"atom-workspace\", \"outline:reveal-cursor\", revealCursor)\n  )\n}\n\nfunction addObservers() {\n  // if the active text editor changed (switched to another editor), then call editorChanged function\n  subscriptions.add(atom.workspace.onDidChangeActiveTextEditor(editorChanged))\n}\n\nexport function deactivate() {\n  onEditorChangedDisposable?.dispose()\n  subscriptions.dispose()\n  view?.destroy()\n  view = undefined\n}\n\n// export function consumeSignal(registry: BusySignalRegistry) {\n//   busySignalProvider = registry.create()\n//   subscriptions.add(busySignalProvider)\n// }\n\nexport async function consumeOutlineProvider(provider: OutlineProvider) {\n  subscriptions.add(/*  providerRegistryEntry */ outlineProviderRegistry.addProvider(provider))\n\n  // NOTE Generate (try) an outline after obtaining a provider for the current active editor\n  // this initial outline is always rendered no matter if it is visible or not,\n  // this is because we can't track if the outline tab becomes visible suddenly later,\n  // or if the editor changes later once outline is visible\n  // so we need to have an outline for the current editor\n  // the following updates rely on the visibility\n  await getOutline()\n}\n\n// disposables returned inside onEditorChangedDisposable\nlet onEditorChangedDisposable: CompositeDisposable | undefined = undefined\n\nasync function editorChanged(editor?: TextEditor) {\n  if (editor === undefined) {\n    return\n  }\n  // dispose the old subscriptions\n  onEditorChangedDisposable?.dispose()\n  onEditorChangedDisposable = new CompositeDisposable() // we can't reuse the CompositeDisposable!\n\n  // NOTE initial outline is always rendered no matter if it is visible or not,\n  // this is because we can't track if the outline tab becomes visible suddenly,\n  // so we always need to show the outline for the correct file\n  // the following updates rely on the visibility\n  await getOutline(editor)\n\n  const largeness = editorLargeness(editor as TextEditor)\n  // How long to wait for the new changes before updating the outline.\n  // A high number will increase the responsiveness of the text editor in large files.\n  const updateDebounceTime = Math.max(largeness / 4, 300) // 1/4 of the line count\n\n  const doubouncedGetOutline = debounce(\n    getOutlintIfVisible as (textEditor: TextEditor) => Promise<void>,\n    updateDebounceTime\n  )\n\n  onEditorChangedDisposable.add(\n    // update the outline if editor stops changing\n    editor.onDidStopChanging(async () => {\n      await doubouncedGetOutline(editor)\n    }),\n\n    // clean up if the editor editor is closed\n    editor.onDidDestroy(() => {\n      setStatus(\"noEditor\")\n    })\n  )\n}\n\nexport function revealCursor() {\n  const editor = atom.workspace.getActiveTextEditor()\n  if (editor === undefined) {\n    return\n  }\n\n  // following cursor disposable\n  if (view !== undefined) {\n    view.selectAtCursorLine(editor)\n  }\n}\n\nexport async function toggleOutlineView() {\n  if (view === undefined) {\n    view = new OutlineView() // create outline pane\n  }\n  const outlinePane = atom.workspace.paneForItem(view)\n  if (outlinePane) {\n    await outlinePane.destroyItem(view)\n    return\n  }\n\n  const rightDock = atom.workspace.getRightDock()\n  const [pane] = rightDock.getPanes()\n\n  pane.addItem(view)\n  pane.activateItem(view)\n\n  rightDock.show()\n\n  // Trigger an editor change whenever an outline is toggeled.\n  try {\n    await editorChanged(atom.workspace.getActiveTextEditor())\n  } catch (e) {\n    notifyError(e as Error)\n  }\n}\n\nfunction getOutlintIfVisible(editor = atom.workspace.getActiveTextEditor()) {\n  // if outline is not visible return\n  if (!isItemVisible(view)) {\n    return\n  }\n  return getOutline(editor)\n}\n\nexport async function getOutline(editor = atom.workspace.getActiveTextEditor()) {\n  if (view === undefined) {\n    view = new OutlineView() // create outline pane\n  } else {\n    view.reset()\n  }\n  // editor\n  if (editor === undefined) {\n    return setStatus(\"noEditor\")\n  }\n\n  // provider\n  const provider = outlineProviderRegistry.getProviderForEditor(editor)\n\n  if (!provider) {\n    return setStatus(\"noProvider\")\n  }\n\n  // const busySignalID = `Outline: ${editor.getPath()}`\n  // busySignalProvider?.add(busySignalID)\n\n  const outline = await provider.getOutline(editor)\n  view.setOutline(outline?.outlineTrees ?? [], editor, Boolean(editorLargeness(editor as TextEditor)))\n\n  // busySignalProvider?.remove(busySignalID)\n}\n\nexport function setStatus(id: \"noEditor\" | \"noProvider\" | \"noResult\") {\n  view?.presentStatus(statuses[id])\n}\n\nexport { default as config } from \"./config.json\"\n"],"names":["el","alignToTop","scrollTops","getScrollTops","scrollIntoView","restoreOverflowHiddenScrollTops","center","scrollIntoViewIfNeeded","el_","Map","set","scrollTop","parentElement","forEach","isOverflowHidden","overflowStyle","style","overflow","getComputedStyle","item","element","getItemElement","undefined","isElementVisible","paneContainer","atom","workspace","paneContainerForItem","isVisible","HTMLElement","display","hidden","offsetHeight","getElement","HAS_WEAKSET_SUPPORT","WeakSet","keys","Object","sameValueZeroEqual","a","b","isPlainObject","value","constructor","isPromiseLike","then","isReactElement","$$typeof","getNewCacheFallback","values","add","push","has","indexOf","getNewCache","createCircularEqualCreator","isEqual","comparator","_comparator","cache","isCacheableA","isCacheableB","hasA","hasB","hasOwnProperty","Function","prototype","bind","call","areObjectsEqual","meta","keysA","index","length","key","reactElementA","reactElementB","HAS_MAP_SUPPORT","HAS_SET_SUPPORT","Set","createComparator","createIsEqual","aShape","Array","isArray","bShape","areArraysEqual","Date","getTime","RegExp","source","global","ignoreCase","multiline","unicode","sticky","lastIndex","areRegExpsEqual","isValueEqual","size","aValue","aKey","bValue","bKey","areMapsEqual","areSetsEqual","deepEqual","OutlineView","[object Object]","this","TreeFilterer","document","createElement","classList","appendChild","toolbar","className","revealCursorButton","innerHTML","addEventListener","commands","dispatch","views","getView","makeOutlineToolbar","createSearchBar","outlineContent","searchBarEditorDisposable","dispose","selectCursorDisposable","searchBarEditor","setText","remove","outlineTree","editor","isLarge","lastEntries","hasEqualContent","pointToElementsMap","clear","addEntriesOnClick","outlineList","createOutlineList","clearContent","largeFileElement","createLargeFileElement","updateSearchBar","dataset","editorRootScope","firstOutlineTree","dataKey","representativeName","treeFilterer","setCandidates","onDidStopChanging","filterOutlineTree","TextEditor","mini","placeholderText","searchBar","isAlive","isItemVisible","text","getText","renderLastOutlienList","query","trim","filterResults","filter","maxResults","usePathScoring","err","error","message","console","reset","candidates","filteredTree","array","elm2","findIndex","elm1","setStatus","filteredOutlineList","status","statusElement","title","description","generateStatusElement","cursor","getLastCursor","clicked","focusedElms","elm","toggleAttribute","cursorPoint","getBufferRow","get","points","previousPoint","point","previousElms","currentElms","onDidChangeCursorPosition","focus","getRootScopeDescriptor","getScopesArray","join","tabLength","getTabLength","setProperty","Math","max","toString","addOutlineEntries","config","ot1","ot2","ot1Len","iEntry","e1","e2","plainText","kind","icon","children","hasChildren","entry","parent","entries","level","sort","rowCompare","startPosition","row","column","sortEntries","symbol","labelElement","innerText","prepend","getIcon","childrenList","event","stopPropagation","passive","foldButton","createFoldButton","entriesElements","len","onClickEntry","addToPointToElementsMap","lastElementChild","pointStartPositionRow","elms","itemStartPosition","editorPane","paneForItem","activate","getCursors","setBufferPosition","autoscroll","iconType","kindTypeGiven","kindType","iconElement","type","kindClass","replace","substring","foldInitially","ProviderRegistry_2","providers","provider","p","priority","splice","atom_1","removeProvider","grammar","getGrammar","scopeName","findProvider","findAllProviders","grammarScopes","statAsync","util_1","fs_1","async","target","cwd","previousActiveItem","getActivePaneItem","getPath","dir","project","relativizePath","isDirectory","path_1","getPaths","wordAtPosition","position","wordRegex","wordRegex_","escaped","getNonWordCharacters","r","includeNonWordCharacters","wordAtPositionFromBuffer","getBuffer","getSingleWordAtPosition","match","wordMatch","buffer","rowRange","rangeForRow","matchData","scanInRange","data","range","start","isLessThanOrEqual","end","isGreaterThan","stop","rangeToTrim","stopRegex","backwardsScanInRange","component","assert_1","screenPositionForMouseEvent","selection","getSelectedText","getCursorScreenPosition","endPosition","regex","line","getTextInRange","exec","some","containsPoint","e","notifications","addError","name","stack","detail","lineCountIfLarge","threashold","largeFileMode","lineCount","getLineCount","lineLengthIfLong","i","lineLength","lineLengthForRow","largeLineCount","longLineLength","longLine","__exportStar","statuses","noEditor","noProvider","noResult","isObject_1","freeGlobal","freeSelf","self","root","now_1","now","reWhitespace","trimmedEndIndex","string","test","charAt","reTrimStart","_baseTrim","slice","_Symbol","Symbol","require$$0","objectProto","nativeObjectToString","symToStringTag","toStringTag","_getRawTag","isOwn","tag","unmasked","result","getRawTag","require$$1","objectToString","baseGetTag","isObjectLike","baseTrim","isObject","isSymbol","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","toNumber","other","valueOf","isBinary","nativeMax","nativeMin","min","debounce_1","func","wait","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","apply","leadingEdge","setTimeout","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","arguments","clearTimeout","cancel","flush","subscriptions","CompositeDisposable","view","outlineProviderRegistry","ProviderRegistry","onEditorChangedDisposable","editorChanged","getOutline","largeness","editorLargeness","updateDebounceTime","doubouncedGetOutline","debounce","getOutlintIfVisible","onDidDestroy","revealCursor","getActiveTextEditor","selectAtCursorLine","toggleOutlineView","outlinePane","destroyItem","rightDock","getRightDock","pane","getPanes","addItem","activateItem","show","notifyError","getProviderForEditor","outline","setOutline","outlineTrees","Boolean","id","presentStatus","onDidChangeActiveTextEditor","catch","addProvider","destroy"],"mappings":"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"}