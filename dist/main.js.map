{"version":3,"file":"main.js","sources":["../src/utils.ts","../src/outlineView.ts","../node_modules/atom-ide-base/src-commons-atom/ProviderRegistry.ts","../src/statuses.ts","../node_modules/lodash/isObject.js","../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_root.js","../node_modules/lodash/now.js","../node_modules/lodash/_trimmedEndIndex.js","../node_modules/lodash/_baseTrim.js","../node_modules/lodash/_Symbol.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/isObjectLike.js","../node_modules/lodash/isSymbol.js","../node_modules/lodash/toNumber.js","../node_modules/lodash/debounce.js","../src/main.ts"],"sourcesContent":["import type { Dock } from \"atom\"\n\n/** A function to detect if an item (view) is visible in Atom */\nexport function isItemVisible(item: object) {\n  const paneContainer = atom.workspace.paneContainerForItem(item)\n  if (paneContainer === undefined) {\n    return false\n  }\n  if (typeof (paneContainer as any).isVisible === \"function\") {\n    return (paneContainer as Dock).isVisible()\n  } else {\n    return true\n  }\n}\n\n/** Throw an Error using atom notifications */\nexport function notifyError(e: Error) {\n  atom.notifications.addError(e.name, {\n    stack: e.stack,\n    detail: e.message,\n  })\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { TextEditor, CursorPositionChangedEvent, Point } from \"atom\"\nimport { OutlineTree } from \"atom-ide-base\"\nimport { isItemVisible } from \"./utils\"\n\nexport class OutlineView {\n  public element: HTMLDivElement\n\n  /** contains the content of the outline which is either the status element or the list element */\n  public outlineContent: HTMLDivElement\n  /** the actual outline list element */\n  private outlineList: HTMLUListElement | undefined = undefined\n\n  /** cache for reveal corsur */\n  private pointToElementsMap = new Map<number, Array<HTMLLIElement>>() // TODO Point to element\n  /** cache for focused elements */\n  private focusedElms: HTMLElement[] | undefined\n  /** cache of last rendered list used to avoid rerendering */\n  lastEntries: OutlineTree[] | undefined\n\n  constructor() {\n    this.element = document.createElement(\"div\")\n\n    this.outlineContent = document.createElement(\"div\")\n    this.element.appendChild(this.outlineContent)\n\n    this.outlineContent.classList.add(\"outline-content\")\n  }\n\n  destroy() {\n    this.element.remove()\n  }\n\n  getElement() {\n    return this.element\n  }\n\n  getTitle() {\n    return \"Outline\"\n  }\n\n  getIconName() {\n    return \"list-unordered\"\n  }\n\n  setOutline(outlineTree: OutlineTree[], editor: TextEditor, isLarge: boolean) {\n    // skip rendering if it is the same\n    // TIME 0.2-1.2ms // the check itself takes ~0.2-0.5ms, so it is better than rerendering\n    if (this.lastEntries !== undefined && hasEqualContent(outlineTree, this.lastEntries)) {\n      this.pointToElementsMap.clear() // empty revealCorsur cache\n      addEntriesOnClick(\n        this.outlineList! /* because this.lastEntries is not undefined */,\n        outlineTree,\n        editor,\n        this.pointToElementsMap,\n        0\n      )\n      return\n    } else {\n      this.lastEntries = outlineTree\n    }\n\n    this.clearContent()\n\n    if (isLarge) {\n      this.outlineContent.appendChild(createLargeFileElement())\n    }\n\n    this.outlineList = createOutlineList(outlineTree, editor, isLarge, this.pointToElementsMap)\n    this.outlineContent.appendChild(this.outlineList)\n  }\n\n  clearContent() {\n    this.outlineContent.innerHTML = \"\"\n    if (this.outlineList !== undefined) {\n      this.outlineList.dataset.editorRootScope = \"\"\n    }\n    this.lastEntries = undefined\n  }\n\n  presentStatus(status: { title: string; description: string }) {\n    this.clearContent()\n\n    const statusElement = status && generateStatusElement(status)\n\n    if (statusElement) {\n      this.outlineContent.appendChild(statusElement)\n    }\n  }\n\n  // callback for scrolling and highlighting the element that the cursor is on\n  selectAtCursorLine(newBufferPosition: CursorPositionChangedEvent[\"newBufferPosition\"]) {\n    // skip if not visible\n    if (!this.isVisible()) {\n      return\n    }\n\n    if (clicked) {\n      // HACK do not scroll when the cursor has moved to a click on the outline entry\n      clicked = false\n      return\n    }\n\n    // TIME: ~0.2-0.3ms\n    // TODO use range of start and end instead of just the line number\n\n    // remove old cursorOn attribue\n    if (this.focusedElms !== undefined) {\n      for (const elm of this.focusedElms) {\n        elm.toggleAttribute(\"cursorOn\", false)\n      }\n    }\n\n    // add new cursorOn attribue\n    const cursorPoint = newBufferPosition.row\n    this.focusedElms = this.pointToElementsMap.get(cursorPoint)\n\n    if (this.focusedElms !== undefined) {\n      for (const elm of this.focusedElms) {\n        elm.toggleAttribute(\"cursorOn\", true)\n        elm.scrollIntoView({\n          block: \"center\", // scroll until the entry is in the center of outline\n        })\n      }\n    }\n  }\n\n  isVisible() {\n    return isItemVisible(this)\n  }\n}\n\n/** create the main outline list */\nfunction createOutlineList(\n  outlineTree: OutlineTree[],\n  editor: TextEditor,\n  isLarge: boolean,\n  pointToElementsMap: Map<number, Array<HTMLLIElement>>\n) {\n  const outlineList = document.createElement(\"ul\")\n  outlineList.dataset.editorRootScope = editor.getRootScopeDescriptor().getScopesArray().join(\" \")\n\n  const tabLength = editor.getTabLength()\n  if (typeof tabLength === \"number\") {\n    outlineList.style.setProperty(\"--editor-tab-length\", Math.max(tabLength / 2, 2).toString(10))\n  }\n  addOutlineEntries(\n    outlineList,\n    outlineTree,\n    editor,\n    /* foldInItially */ isLarge || atom.config.get(\"atom-ide-outline.foldInitially\"),\n    0\n  )\n  // TIME 0.2-0.5m\n  addEntriesOnClick(outlineList, outlineTree, editor, pointToElementsMap, 0)\n  return outlineList\n}\n\n/** Compares the content of the two given {OutlineTree[]}\n *  It only compares the content that affects rendering\n */\nfunction hasEqualContent(ot1: OutlineTree[], ot2: OutlineTree[]) {\n  // simple compare\n  if (ot1 === ot2) {\n    return true\n  } else {\n    // compare length\n    const ot1Len = ot1.length\n    const ot2Len = ot2.length\n    if (ot1Len !== ot2Len) {\n      return false\n    }\n    // compare the content\n    for (let iEntry = 0; iEntry < ot1Len; iEntry++) {\n      const e1 = ot1[iEntry]\n      const e2 = ot2[iEntry]\n      if (\n        e1.representativeName !== e2.representativeName ||\n        e1.plainText !== e2.plainText ||\n        e1.kind !== e2.kind ||\n        e1.icon !== e2.icon ||\n        !hasEqualContent(e1.children, e2.children)\n      ) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\nfunction createLargeFileElement() {\n  const largeFileElement = document.createElement(\"div\")\n  largeFileElement.innerHTML = `<span class=\"large-file-mode\">Large file mode</span>`\n  return largeFileElement\n}\n\nfunction generateStatusElement(status: { title: string; description: string }) {\n  const element = document.createElement(\"div\")\n  element.className = \"status\"\n\n  const { title = \"\", description = \"\" } = status\n  element.innerHTML = `<h1>${title}</h1>\n  <span>${description}</span>`\n\n  return element\n}\n\nfunction hasChildren(entry: OutlineTree) {\n  return entry.children.length >= 1\n}\n\nfunction sortEntries(entries: OutlineTree[]) {\n  if (atom.config.get(\"atom-ide-outline.sortEntries\")) {\n    entries.sort((e1: OutlineTree, e2: OutlineTree) => {\n      const rowCompare = e1.startPosition.row - e2.startPosition.row\n      if (rowCompare === 0) {\n        // compare based on column if on the same row\n        return e1.startPosition.column - e1.startPosition.column\n      }\n      return rowCompare\n    })\n  }\n}\n\nfunction addOutlineEntries(\n  parent: HTMLUListElement,\n  entries: OutlineTree[],\n  editor: TextEditor,\n  isLarge: boolean,\n  level: number\n) {\n  // NOTE: this function is called multiple times with each update in an editor!\n  // a few of the calls is slow ~1-100ms\n\n  // TIME 0.1ms\n  sortEntries(entries)\n\n  for (const item of entries) {\n    const symbol = document.createElement(\"li\")\n\n    // symbol.setAttribute(\"level\", `${level}`); // store level in the element\n\n    // Hold an entry in a dedicated element to prevent hover conflicts - hover over an <li> tag would be cought by a parent <li>\n    // TIME: ~0-0.1ms\n    const labelElement = document.createElement(\"span\")\n\n    // TODO support item.tokenizedText\n    labelElement.innerText = (item.representativeName || item.plainText) ?? \"\"\n\n    labelElement.prepend(/* iconElement */ getIcon(item?.icon, item?.kind))\n\n    symbol.appendChild(labelElement)\n\n    if (hasChildren(item)) {\n      // create Child elements\n      // TIME 0-0.2ms\n      const childrenList = document.createElement(\"ul\")\n      childrenList.style.setProperty(\"--indent-level\", (level + 1).toString(10))\n      childrenList.addEventListener(\"click\", (event) => event.stopPropagation(), { passive: true })\n      symbol.appendChild(childrenList)\n\n      // fold Button\n      const foldButton = createFoldButton(childrenList, isLarge)\n      labelElement.prepend(foldButton)\n\n      // add children to outline\n      // TIME: last one of each batch is slower 0-20ms\n      addOutlineEntries(childrenList, item.children, editor, isLarge, level + 1)\n    }\n\n    // TIME: <0.1ms\n    parent.appendChild(symbol)\n  }\n}\n\n/** Adds onClick to the outline entries.\n * @attention The assumption about the type of Elements are added using `as HTML...`. After editing code, make sure that the types are correct\n */\nfunction addEntriesOnClick(\n  parent: HTMLUListElement,\n  entries: OutlineTree[],\n  editor: TextEditor,\n  pointToElementsMap: Map<number, Array<HTMLLIElement>>,\n  level: number\n) {\n  const entriesElements = parent.children\n  for (let iEntry = 0, len = entries.length; iEntry < len; iEntry++) {\n    const item = entries[iEntry]\n    const element = entriesElements[iEntry] as HTMLLIElement\n\n    // Cursor reposition on click\n    element.addEventListener(\"click\", () => onClickEntry(item.startPosition, editor), { passive: true })\n\n    // update the cache for selectAtCursorLine\n    addToPointToElementsMap(pointToElementsMap, item.startPosition.row, element)\n\n    if (hasChildren(item)) {\n      const chilrenRootElement = element.lastElementChild as HTMLUListElement\n      addEntriesOnClick(chilrenRootElement, item.children, editor, pointToElementsMap, level + 1)\n    }\n  }\n}\n\n/** update start position => elements map used in `selectAtCursorLine` */\nfunction addToPointToElementsMap(\n  pointToElementsMap: Map<number, Array<HTMLLIElement>>,\n  pointStartPositionRow: number,\n  element: HTMLLIElement\n) {\n  // TIME: 0-0.2ms\n  const elms = pointToElementsMap.get(pointStartPositionRow)\n  if (elms !== undefined) {\n    elms.push(element)\n    pointToElementsMap.set(pointStartPositionRow, elms)\n  } else {\n    pointToElementsMap.set(pointStartPositionRow, [element])\n  }\n}\n\nlet clicked: boolean = false // HACK used to prevent scrolling in the outline list when an entry is clicked\n\nfunction onClickEntry(itemStartPosition: Point, editor: TextEditor) {\n  // only uses a reference to the editor and the pane and corsur are calculated on the fly\n  const editorPane = atom.workspace.paneForItem(editor)\n  if (editorPane === undefined) {\n    return\n  }\n  editorPane.activate()\n\n  editor.getCursors()[0].setBufferPosition(itemStartPosition, {\n    autoscroll: true,\n  })\n  // HACK\n  clicked = true\n}\n\nfunction getIcon(iconType: string | undefined, kindType: string | undefined) {\n  // LSP specification: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_documentSymbol\n  // atom-languageclient mapping: https://github.com/atom/atom-languageclient/blob/485bb9d706b422456640c9070eee456ef2cf09c0/lib/adapters/outline-view-adapter.ts#L270\n\n  const iconElement = document.createElement(\"span\")\n  iconElement.classList.add(\"outline-icon\")\n\n  // if iconType given instead\n  if (kindType === undefined && iconType !== undefined) {\n    kindType = iconType\n  }\n\n  let type: string = \"ðŸž‡\"\n  if (typeof kindType === \"string\" && kindType.length > 0) {\n    let kindClass: string\n    // hasKind\n    if (kindType.indexOf(\"type-\") === 0) {\n      // supplied with type-...\n      kindClass = `${kindType}`\n      type = kindType.replace(\"type-\", \"\")\n    } else {\n      // supplied without type-\n      kindClass = `type-${kindType}`\n      type = kindType\n    }\n    iconElement.classList.add(kindClass)\n  }\n\n  iconElement.innerHTML = `<span>${type.substring(0, 3)}</span>`\n\n  return iconElement\n}\n\nfunction createFoldButton(childrenList: HTMLUListElement, foldInitially: boolean) {\n  // TIME: ~0.1-0.5ms\n  // fold button\n  const foldButton = document.createElement(\"button\")\n\n  if (foldInitially) {\n    // collapse in large files by default\n    childrenList.hidden = true\n    foldButton.classList.add(\"outline-fold-btn\", \"collapsed\")\n  } else {\n    foldButton.classList.add(\"outline-fold-btn\", \"expanded\")\n  }\n\n  // fold listener\n  foldButton.addEventListener(\n    \"click\",\n    (event) => {\n      childrenList.hidden = !childrenList.hidden\n      if (childrenList.hidden) {\n        foldButton.classList.remove(\"expanded\")\n        foldButton.classList.add(\"collapsed\")\n      } else {\n        foldButton.classList.remove(\"collapsed\")\n        foldButton.classList.add(\"expanded\")\n      }\n      event.stopPropagation()\n    },\n    { passive: true }\n  )\n  return foldButton\n}\n","import { Disposable, TextEditor } from \"atom\"\nimport { Provider as ProviderTypes, BusySignalProvider, FindReferencesProvider } from \"../types-packages/main.d\"\n\nexport class ProviderRegistry<Provider extends Exclude<ProviderTypes, BusySignalProvider | FindReferencesProvider>> {\n  private providers: Array<Provider>\n\n  constructor() {\n    this.providers = []\n  }\n\n  addProvider(provider: Provider): Disposable {\n    const index = this.providers.findIndex((p) => provider.priority > p.priority)\n    if (index === -1) {\n      this.providers.push(provider)\n    } else {\n      this.providers.splice(index, 0, provider)\n    }\n    return new Disposable(() => {\n      this.removeProvider(provider)\n    })\n  }\n\n  removeProvider(provider: Provider): void {\n    const index = this.providers.indexOf(provider)\n    if (index !== -1) {\n      this.providers.splice(index, 1)\n    }\n  }\n\n  // TODO deprecate since there can be N providers.\n  getProviderForEditor(editor: TextEditor): Provider | null {\n    const grammar = editor.getGrammar().scopeName\n    return this.findProvider(grammar)\n  }\n\n  // TODO create an ordering or priority aware util to prefer instead.\n  getAllProvidersForEditor(editor: TextEditor): Iterable<Provider> {\n    const grammar = editor.getGrammar().scopeName\n    return this.findAllProviders(grammar)\n  }\n\n  findProvider(grammar: string): Provider | null {\n    for (const provider of this.findAllProviders(grammar)) {\n      return provider\n    }\n    return null\n  }\n\n  /**\n   * Iterates over all providers matching the grammar, in priority order.\n   */\n  *findAllProviders(grammar: string): Iterable<Provider> {\n    for (const provider of this.providers) {\n      if (provider.grammarScopes == null || provider.grammarScopes.indexOf(grammar) !== -1) {\n        yield provider\n      }\n    }\n  }\n}\n","export const statuses = {\n  noEditor: {\n    title: \"Outline is unavailable.\",\n    description: \"Open a text editor.\",\n  },\n  noProvider: {\n    title: \"Provider is unavailable\",\n    description:\n      \"Looks like a provider for this type of file is not available. Check if a relevant IDE language package is installed and has outline support, or try adding one from Atom's package registry (e.g.: atom-ide-javascript, atom-typescript, ide-python, ide-rust, ide-css, ide-json).\",\n  },\n}\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n","var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","import { CompositeDisposable, TextEditor } from \"atom\"\nimport { OutlineView } from \"./outlineView\"\nimport { OutlineProvider } from \"atom-ide-base\"\nimport { ProviderRegistry } from \"atom-ide-base/commons-atom/ProviderRegistry\"\nimport { notifyError } from \"./utils\"\n\nexport { statuses } from \"./statuses\" // for spec\nimport { statuses } from \"./statuses\"\nimport debounce from \"lodash/debounce\"\n\nconst subscriptions = new CompositeDisposable()\n\nlet view: OutlineView | undefined\nexport const outlineProviderRegistry = new ProviderRegistry<OutlineProvider>()\n\n// let busySignalProvider: BusySignalProvider | undefined // service might be consumed late\n\nexport function activate() {\n  addCommands()\n  addObservers()\n  if (atom.config.get(\"atom-ide-outline.initialDisplay\")) {\n    // initially show outline pane\n    toggleOutlineView().catch((e) => {\n      notifyError(e)\n    })\n  }\n}\n\nexport function deactivate() {\n  onDidCompositeDisposable?.dispose?.()\n  subscriptions.dispose()\n  view?.destroy()\n  view = undefined\n}\n\n// export function consumeSignal(registry: BusySignalRegistry) {\n//   busySignalProvider = registry.create()\n//   subscriptions.add(busySignalProvider)\n// }\n\nexport async function consumeOutlineProvider(provider: OutlineProvider) {\n  subscriptions.add(/*  providerRegistryEntry */ outlineProviderRegistry.addProvider(provider))\n\n  // Generate (try) an outline after obtaining a provider\n  await getOutline()\n}\n\nfunction addCommands() {\n  subscriptions.add(\n    /* outlineToggle */ atom.commands.add(\"atom-workspace\", \"outline:toggle\", toggleOutlineView),\n    /* revealCursor */ atom.commands.add(\"atom-workspace\", \"outline:reveal-cursor\", revealCursor)\n  )\n}\n\nconst longLineLength = atom.config.get(\"linter-ui-default.longLineLength\") || 4000\nconst largeFileLineCount = atom.config.get(\"linter-ui-default.largeFileLineCount\") / 6 || 3000 // minimum number of lines to trigger large file optimizations\nfunction lineCountIfLarge(editor: TextEditor) {\n  // @ts-ignore\n  if (editor.largeFileMode) {\n    return 20000\n  }\n  const lineCount = editor.getLineCount()\n  if (lineCount >= largeFileLineCount) {\n    return lineCount\n  } else {\n    const buffer = editor.getBuffer()\n    for (let i = 0, len = lineCount; i < len; i++) {\n      if (buffer.lineLengthForRow(i) > longLineLength) {\n        return longLineLength\n      }\n    }\n    return 0 // small file\n  }\n}\n\n// disposables returned inside the oberservers\nlet onDidCompositeDisposable: CompositeDisposable | null\n\nfunction addObservers() {\n  onDidCompositeDisposable = new CompositeDisposable()\n  const activeTextEditorObserver = atom.workspace.observeActiveTextEditor(editorChanged)\n  subscriptions.add(activeTextEditorObserver)\n}\n\nasync function editorChanged(editor?: TextEditor) {\n  if (editor === undefined) {\n    return\n  }\n  // dispose the old subscriptions\n  onDidCompositeDisposable?.dispose?.()\n\n  await getOutline(editor) // initial outline\n\n  const lineCount = lineCountIfLarge(editor as TextEditor)\n  // How long to wait for the new changes before updating the outline.\n  // A high number will increase the responsiveness of the text editor in large files.\n  const updateDebounceTime = Math.max(lineCount / 5, 300) // 1/5 of the line count\n\n  const doubouncedGetOutline = debounce(getOutline as (textEditor: TextEditor) => Promise<void>, updateDebounceTime)\n\n  onDidCompositeDisposable!.add(\n    // update the outline if editor stops changing\n    editor.onDidStopChanging(async () => {\n      await doubouncedGetOutline(editor)\n    }),\n\n    // clean up if the editor editor is closed\n    editor.onDidDestroy(() => {\n      setStatus(\"noEditor\")\n    })\n  )\n}\n\nexport function revealCursor() {\n  const editor = atom.workspace.getActiveTextEditor()\n  if (editor === undefined) {\n    return\n  }\n\n  // following cursor disposable\n  if (view !== undefined) {\n    view.selectAtCursorLine(editor.getCursorBufferPosition())\n  }\n}\n\nexport async function toggleOutlineView() {\n  if (view === undefined) {\n    view = new OutlineView() // create outline pane\n  }\n  const outlinePane = atom.workspace.paneForItem(view)\n  if (outlinePane) {\n    outlinePane.destroyItem(view)\n    return\n  }\n\n  const rightDock = atom.workspace.getRightDock()\n  const [pane] = rightDock.getPanes()\n\n  pane.addItem(view)\n  pane.activateItem(view)\n\n  rightDock.show()\n\n  // Trigger an editor change whenever an outline is toggeled.\n  try {\n    await editorChanged(atom.workspace.getActiveTextEditor())\n  } catch (e) {\n    notifyError(e)\n  }\n}\n\nexport async function getOutline(editor = atom.workspace.getActiveTextEditor()) {\n  if (view === undefined) {\n    view = new OutlineView() // create outline pane\n  }\n  // if outline is not visible return\n  if (!view.isVisible()) {\n    return\n  }\n  // editor\n  if (editor === undefined) {\n    return setStatus(\"noEditor\")\n  }\n\n  // provider\n  const provider = outlineProviderRegistry.getProviderForEditor(editor)\n\n  if (!provider) {\n    return setStatus(\"noProvider\")\n  }\n\n  // const target = editor.getPath()\n\n  // const busySignalID = `Outline: ${target}`\n  // // @ts-ignore\n  // busySignalProvider?.add(busySignalID, { onlyForFile: target })\n\n  const outline = await provider.getOutline(editor)\n  view.setOutline(outline?.outlineTrees ?? [], editor, Boolean(lineCountIfLarge(editor as TextEditor)))\n\n  // busySignalProvider?.remove(busySignalID)\n}\n\nexport function setStatus(id: \"noEditor\" | \"noProvider\") {\n  view?.presentStatus(statuses[id])\n}\n\nexport { default as config } from \"./config.json\"\n"],"names":["notifyError","e","atom","notifications","addError","name","stack","detail","message","OutlineView","[object Object]","this","undefined","Map","element","document","createElement","outlineContent","appendChild","classList","add","remove","outlineTree","editor","isLarge","lastEntries","hasEqualContent","pointToElementsMap","clear","addEntriesOnClick","outlineList","clearContent","largeFileElement","innerHTML","createLargeFileElement","dataset","editorRootScope","getRootScopeDescriptor","getScopesArray","join","tabLength","getTabLength","style","setProperty","Math","max","toString","addOutlineEntries","config","get","createOutlineList","status","statusElement","className","title","description","generateStatusElement","newBufferPosition","isVisible","clicked","focusedElms","elm","toggleAttribute","cursorPoint","row","scrollIntoView","block","item","paneContainer","workspace","paneContainerForItem","isItemVisible","ot1","ot2","ot1Len","length","iEntry","e1","e2","representativeName","plainText","kind","icon","children","hasChildren","entry","parent","entries","level","sort","rowCompare","startPosition","column","sortEntries","symbol","labelElement","innerText","prepend","getIcon","childrenList","addEventListener","event","stopPropagation","passive","foldButton","createFoldButton","entriesElements","len","onClickEntry","addToPointToElementsMap","lastElementChild","pointStartPositionRow","elms","push","set","itemStartPosition","editorPane","paneForItem","activate","getCursors","setBufferPosition","autoscroll","iconType","kindType","iconElement","type","kindClass","indexOf","replace","substring","foldInitially","hidden","exports","providers","provider","index","findIndex","p","priority","splice","atom_1","removeProvider","grammar","getGrammar","scopeName","findProvider","findAllProviders","grammarScopes","statuses","noEditor","noProvider","value","global","Object","freeSelf","self","freeGlobal","Function","root","Date","now","reWhitespace","string","test","charAt","reTrimStart","slice","trimmedEndIndex","Symbol","objectProto","prototype","hasOwnProperty","nativeObjectToString","symToStringTag","toStringTag","isOwn","call","tag","unmasked","result","getRawTag","objectToString","isObjectLike","baseGetTag","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","isSymbol","isObject","other","valueOf","baseTrim","isBinary","nativeMax","nativeMin","min","func","wait","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","apply","leadingEdge","setTimeout","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","arguments","clearTimeout","toNumber","cancel","flush","subscriptions","CompositeDisposable","view","outlineProviderRegistry","ProviderRegistry","longLineLength","largeFileLineCount","lineCountIfLarge","largeFileMode","lineCount","getLineCount","buffer","getBuffer","i","lineLengthForRow","onDidCompositeDisposable","async","editorChanged","dispose","getOutline","updateDebounceTime","doubouncedGetOutline","debounce","onDidStopChanging","onDidDestroy","setStatus","revealCursor","getActiveTextEditor","selectAtCursorLine","getCursorBufferPosition","toggleOutlineView","outlinePane","destroyItem","rightDock","getRightDock","pane","getPanes","addItem","activateItem","show","getProviderForEditor","outline","setOutline","outlineTrees","Boolean","id","presentStatus","commands","activeTextEditorObserver","observeActiveTextEditor","addObservers","catch","addProvider","destroy"],"mappings":"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"}